import { useState, useEffect, useRef, useCallback } from "react";

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WORD DATABASE â€” 40 WORDS WITH FULL ETYMOLOGY
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const WORD_BANK = [
  { word:"ephemeral", def:"Lasting for a very short time", pos:"adj", ipa:"/ÉªËˆfÉ›m.É™r.É™l/", origin:"Greek", year:"1560s", etymology:"From Greek ephÄ“meros â€” 'lasting only a day'", roots:[{part:"epi-",meaning:"upon",lang:"Greek"},{part:"hÄ“mera",meaning:"day",lang:"Greek"}], evolution:["ephÄ“meros (Grk)","ephemerus (Lat)","Ã©phÃ©mÃ¨re (Fr)","ephemeral"], relatives:["ephemera","ephemeris"], funFact:"Originally a medical term for fevers lasting only a day. Mayflies (Ephemeroptera) live just 24 hours as adults." },
  { word:"mellifluous", def:"Sweet-sounding; pleasant to hear", pos:"adj", ipa:"/mÉ›ËˆlÉªf.lu.É™s/", origin:"Latin", year:"1400s", etymology:"From Latin mellifluus â€” 'flowing with honey'", roots:[{part:"mel",meaning:"honey",lang:"Latin"},{part:"fluere",meaning:"to flow",lang:"Latin"}], evolution:["mellifluus (Lat)","mellifluous (Eng)"], relatives:["fluent","fluid","confluence","superfluous"], funFact:"The root 'mel' also gives us 'molasses' (via Portuguese) and 'marmalade' (via Greek melimelon, 'honey apple')." },
  { word:"serendipity", def:"Happy discoveries made by chance", pos:"noun", ipa:"/ËŒsÉ›r.É™nËˆdÉªp.Éª.ti/", origin:"English (coined)", year:"1754", etymology:"Coined by Horace Walpole from 'The Three Princes of Serendip'", roots:[{part:"Serendip",meaning:"old name for Sri Lanka",lang:"Persian"},{part:"-ity",meaning:"quality of",lang:"Latin suffix"}], evolution:["SarandÄ«b (Arabic)","Serendip (Persian)","serendipity (1754)"], relatives:["serendipitous"], funFact:"One of few English words with a precise birthday: January 28, 1754, in a letter by Walpole." },
  { word:"sycophant", def:"A person who flatters to gain advantage", pos:"noun", ipa:"/ËˆsÉªk.É™.fÃ¦nt/", origin:"Greek", year:"1530s", etymology:"From Greek sykophantÄ“s â€” literally 'one who shows the fig'", roots:[{part:"sykon",meaning:"fig",lang:"Greek"},{part:"phainein",meaning:"to show",lang:"Greek"}], evolution:["sykophantÄ“s (Grk)","sycophanta (Lat)","sycophant"], relatives:["sycophancy","epiphany","phenomenon","phantom"], funFact:"One theory: exporting figs from Athens was illegal, and informers who reported violators were called 'fig-showers.'" },
  { word:"nostalgia", def:"A sentimental longing for the past", pos:"noun", ipa:"/nÉ’ËˆstÃ¦l.dÊ’É™/", origin:"Greek (coined)", year:"1688", etymology:"Coined by Swiss physician Johannes Hofer as a medical diagnosis for severe homesickness", roots:[{part:"nostos",meaning:"homecoming",lang:"Greek"},{part:"algos",meaning:"pain",lang:"Greek"}], evolution:["nostos + algos (Grk)","nostalgia (New Latin, 1688)","nostalgia (Eng)"], relatives:["nostalgic","neuralgia","analgesic"], funFact:"Originally a real medical condition! Swiss soldiers abroad were prescribed opium, leeches, and trips to the Alps." },
  { word:"algorithm", def:"A process or set of rules for problem-solving", pos:"noun", ipa:"/ËˆÃ¦l.É¡É™.rÉªÃ°.É™m/", origin:"Arabic", year:"1200s", etymology:"From the Latinized name of Persian mathematician al-KhwÄrizmÄ«", roots:[{part:"al-KhwÄrizmÄ«",meaning:"the one from Khwarezm (Uzbekistan)",lang:"Arabic"}], evolution:["al-KhwÄrizmÄ« (Arabic)","algorismus (Med. Latin)","algorithm (Eng)"], relatives:["algebra","algorism","arithmetic"], funFact:"Al-KhwÄrizmÄ«'s 9th-century book was so influential his name became the word for mathematical procedures. His other book gave us 'algebra.'" },
  { word:"lunatic", def:"Wildly foolish or mentally unstable", pos:"noun/adj", ipa:"/ËˆluË.nÉ™.tÉªk/", origin:"Latin", year:"1290s", etymology:"From Latin lunaticus â€” 'moon-struck'", roots:[{part:"luna",meaning:"the moon",lang:"Latin"},{part:"-aticus",meaning:"pertaining to",lang:"Latin"}], evolution:["luna (Lat)","lunaticus (Lat)","lunatique (OFr)","lunatic"], relatives:["lunar","lunacy","sublunary"], funFact:"English law once defined a lunatic as someone who lost reason 'upon the full of the moon.' Studies show no real correlation." },
  { word:"disaster", def:"A sudden event causing great damage", pos:"noun", ipa:"/dÉªËˆzÃ¦s.tÉ™r/", origin:"Italian/Greek", year:"1590s", etymology:"From Italian disastro â€” literally 'ill-starred'", roots:[{part:"dis-",meaning:"away, negation",lang:"Latin"},{part:"astro",meaning:"star",lang:"Greek"}], evolution:["astron (Grk)","disastro (Ital)","dÃ©sastre (Fr)","disaster"], relatives:["asteroid","astronomy","astrology","astronaut"], funFact:"Reflects the belief that stars governed fate. Shakespeare's King Lear blames 'these late eclipses' for social chaos." },
  { word:"quarantine", def:"Isolation to prevent spread of disease", pos:"noun", ipa:"/ËˆkwÉ’r.É™n.tiËn/", origin:"Italian", year:"1660s", etymology:"From Italian quarantina â€” 'space of forty days'", roots:[{part:"quaranta",meaning:"forty",lang:"Italian"},{part:"-ina",meaning:"period of",lang:"Italian"}], evolution:["quadraginta (Lat)","quaranta (Ital)","quarantina","quarantine"], relatives:["quarter","quadrant","quaternary"], funFact:"During the Black Death, Venice required ships to anchor 40 days before landing. Why 40? Possibly biblical â€” Moses, Jesus both had 40-day trials." },
  { word:"sarcasm", def:"Irony used to mock or convey contempt", pos:"noun", ipa:"/ËˆsÉ‘Ër.kÃ¦z.É™m/", origin:"Greek", year:"1570s", etymology:"From Greek sarkasmos â€” 'to tear flesh, gnash teeth'", roots:[{part:"sarx",meaning:"flesh",lang:"Greek"},{part:"sarkazein",meaning:"to strip off flesh",lang:"Greek"}], evolution:["sarkazein (Grk)","sarkasmos (Grk)","sarcasmus (Lat)","sarcasm"], relatives:["sarcastic","sarcophagus","sarcoma"], funFact:"Sarcophagus ('flesh-eater') shares the same root â€” the limestone was believed to decompose bodies. Sarcasm and sarcophagus: etymological cousins." },
  { word:"clue", def:"Evidence that helps solve a mystery", pos:"noun", ipa:"/kluË/", origin:"Greek myth", year:"1590s", etymology:"From 'clew,' a ball of thread â€” referencing Theseus and the Minotaur", roots:[{part:"clew",meaning:"ball of yarn",lang:"Old English"}], evolution:["cliwen (OE)","clewe (Mid.Eng)","clew/clue (figurative)"], relatives:["clew (nautical)","unravel"], funFact:"Theseus navigated the Minotaur's labyrinth by unwinding a 'clew' of thread. A 'clue' literally guides you through a maze of confusion." },
  { word:"salary", def:"A fixed regular payment for work", pos:"noun", ipa:"/ËˆsÃ¦l.É™r.i/", origin:"Latin", year:"1300s", etymology:"From Latin salarium â€” 'salt money' paid to Roman soldiers", roots:[{part:"sal",meaning:"salt",lang:"Latin"},{part:"-arium",meaning:"connected to",lang:"Latin"}], evolution:["sal (Lat)","salarium (Lat)","salaire (OFr)","salary"], relatives:["saline","salad","sauce","sausage"], funFact:"Roman soldiers were partly paid in salt â€” it was crucial for food preservation. 'Worth his salt' comes from this same idea." },
  { word:"muscle", def:"Fibrous tissue that contracts for movement", pos:"noun", ipa:"/ËˆmÊŒs.É™l/", origin:"Latin", year:"1530s", etymology:"From Latin musculus â€” literally 'little mouse'", roots:[{part:"mus",meaning:"mouse",lang:"Latin"},{part:"-culus",meaning:"little",lang:"Latin"}], evolution:["mus (Lat)","musculus (Lat)","muscle (OFr)","muscle"], relatives:["mussel","mouse","muscular"], funFact:"Romans thought a flexing bicep looked like a mouse running under skin. Greeks agreed â€” mys meant both 'mouse' and 'muscle.' Mussel the shellfish: also mouse-shaped." },
  { word:"psychology", def:"The study of mind and behavior", pos:"noun", ipa:"/saÉªËˆkÉ’l.É™.dÊ’i/", origin:"Greek", year:"1650s", etymology:"From Greek psykhÄ“ (soul/mind) + logos (study)", roots:[{part:"psykhÄ“",meaning:"soul, breath of life",lang:"Greek"},{part:"logos",meaning:"study, reason",lang:"Greek"}], evolution:["psykhÄ“ + logos (Grk)","psychologia (New Lat)","psychology"], relatives:["psyche","psychiatry","psychedelic","logic"], funFact:"PsykhÄ“ means 'breath' â€” Greeks equated breath with the soul, since it leaves at death. In myth, Psyche was a mortal whose name became synonymous with the human soul." },
  { word:"toxic", def:"Poisonous; harmful or destructive", pos:"adj", ipa:"/ËˆtÉ’k.sÉªk/", origin:"Greek", year:"1660s", etymology:"From Greek toxikon pharmakon â€” 'poison for arrows'", roots:[{part:"toxon",meaning:"bow (archery)",lang:"Greek"},{part:"-ikon",meaning:"pertaining to",lang:"Greek"}], evolution:["toxon (Grk)","toxikon (Grk)","toxicum (Lat)","toxic"], relatives:["toxin","toxicology","intoxicate"], funFact:"The word for 'poison' comes from 'bow' â€” Scythians coated arrowheads in poison. 'Intoxicate' literally means 'to put arrow-poison into' someone." },
  { word:"trivial", def:"Of little value or importance", pos:"adj", ipa:"/ËˆtrÉªv.i.É™l/", origin:"Latin", year:"1430s", etymology:"From Latin trivialis â€” 'found at the crossroads, commonplace'", roots:[{part:"tri-",meaning:"three",lang:"Latin"},{part:"via",meaning:"road",lang:"Latin"}], evolution:["trivium (Lat)","trivialis (Lat)","trivial"], relatives:["trivia","via","deviate","voyage"], funFact:"Where three roads met, people chatted about unimportant things. In medieval universities, the 'trivium' was the 'easy' introductory curriculum." },
  { word:"candidate", def:"A person nominated for a position", pos:"noun", ipa:"/ËˆkÃ¦n.dÉª.deÉªt/", origin:"Latin", year:"1600s", etymology:"From Latin candidatus â€” 'one dressed in white'", roots:[{part:"candidus",meaning:"white, shining",lang:"Latin"},{part:"-atus",meaning:"clothed in",lang:"Latin"}], evolution:["candere (Lat)","candidus","candidatus","candidate"], relatives:["candid","candle","candor","incandescent","chandelier"], funFact:"Roman politicians wore whitened togas (toga candida) to symbolize purity. 'Candidate' = 'the one in the white toga.' Same root gives us 'candle.'" },
  { word:"companion", def:"A person one spends time with", pos:"noun", ipa:"/kÉ™mËˆpÃ¦n.jÉ™n/", origin:"Latin", year:"1300s", etymology:"From Latin companio â€” 'one who shares bread'", roots:[{part:"com-",meaning:"together",lang:"Latin"},{part:"panis",meaning:"bread",lang:"Latin"}], evolution:["com + panis (Lat)","companio","compaignon (OFr)","companion"], relatives:["company","accompany","pantry","panini"], funFact:"Your 'companion' is someone you break bread with. Even 'lord' comes from Old English hlÄford: 'loaf-guardian.'" },
  { word:"vaccine", def:"A substance stimulating immunity", pos:"noun", ipa:"/ËˆvÃ¦k.siËn/", origin:"Latin", year:"1799", etymology:"From Latin vaccinus â€” 'pertaining to cows'", roots:[{part:"vacca",meaning:"cow",lang:"Latin"},{part:"-inus",meaning:"of the nature of",lang:"Latin"}], evolution:["vacca (Lat)","vaccinus","vaccine (coined by Jenner)"], relatives:["vaccinate","vaccination","vaquero"], funFact:"Jenner noticed milkmaids who caught cowpox never got smallpox. Every time we say 'vaccine' we're literally saying 'cow stuff.'" },
  { word:"mortgage", def:"A loan secured against property", pos:"noun", ipa:"/ËˆmÉ”Ër.É¡ÉªdÊ’/", origin:"Old French", year:"1390s", etymology:"From Old French mort gage â€” literally 'death pledge'", roots:[{part:"mort",meaning:"death",lang:"Old French"},{part:"gage",meaning:"pledge",lang:"Old French"}], evolution:["mors (Lat) + wadium (Gmc)","mort gage (OFr)","mortgage"], relatives:["mortal","mortuary","mortify","wage","wager"], funFact:"Called 'death pledge' because the deal 'dies' one way or another: debt paid (pledge dies) or payment fails (deal dies)." },
  { word:"gymnasium", def:"A building for physical exercise", pos:"noun", ipa:"/dÊ’ÉªmËˆneÉª.zi.É™m/", origin:"Greek", year:"1590s", etymology:"From Greek gymnasion â€” 'a place to exercise naked'", roots:[{part:"gymnos",meaning:"naked",lang:"Greek"},{part:"-asion",meaning:"place for",lang:"Greek"}], evolution:["gymnos (Grk)","gymnasion","gymnasium"], relatives:["gymnastics","gymnast","gymnosperm"], funFact:"Greek athletes trained completely nude. Plato's Academy and Aristotle's Lyceum were both gymnasia. Pine trees are 'gymnosperms' â€” 'naked seeds.'" },
  { word:"barbarian", def:"A person from an 'uncivilized' culture", pos:"noun", ipa:"/bÉ‘ËrËˆbÉ›É™r.i.É™n/", origin:"Greek", year:"1400s", etymology:"From Greek barbaros â€” imitating incomprehensible speech: 'bar-bar-bar'", roots:[{part:"barbaros",meaning:"foreign, one who babbles",lang:"Greek"}], evolution:["barbaros (Grk)","barbarus (Lat)","barbare (OFr)","barbarian"], relatives:["barbaric","barbarous","Barbary Coast"], funFact:"To Greeks, foreign languages sounded like 'bar bar bar.' Sanskrit barbara also means 'stammering.' One of history's oldest examples of linguistic ethnocentrism." },
  { word:"panic", def:"Sudden uncontrollable fear", pos:"noun", ipa:"/ËˆpÃ¦n.Éªk/", origin:"Greek myth", year:"1600s", etymology:"From Greek panikos â€” 'of the god Pan'", roots:[{part:"Pan",meaning:"god of forests and wild nature",lang:"Greek"},{part:"-ikos",meaning:"pertaining to",lang:"Greek"}], evolution:["Pan (god)","panikos (Grk)","panicus (Lat)","panic"], relatives:["pandemic","panorama","panacea"], funFact:"Pan lurked in remote places causing sudden, irrational terror â€” especially at noon when forests went silent. Greeks blamed Pan for mysterious stampedes of herds." },
  { word:"supercilious", def:"Acting as though superior to others", pos:"adj", ipa:"/ËŒsuË.pÉ™rËˆsÉªl.i.É™s/", origin:"Latin", year:"1520s", etymology:"From Latin supercilium â€” literally 'eyebrow'", roots:[{part:"super-",meaning:"above",lang:"Latin"},{part:"cilium",meaning:"eyelid",lang:"Latin"}], evolution:["supercilium (Lat)","superciliosus (Lat)","supercilious"], relatives:["superb","superficial","cilia"], funFact:"The raised eyebrow is a universal gesture of condescension. Romans were so aware of this that 'eyebrow' became their word for arrogance itself." },
  { word:"galaxy", def:"A system of millions of stars", pos:"noun", ipa:"/ËˆÉ¡Ã¦l.É™k.si/", origin:"Greek", year:"1380s", etymology:"From Greek galaxias kyklos â€” 'milky circle'", roots:[{part:"gala",meaning:"milk",lang:"Greek"},{part:"-xias",meaning:"pertaining to",lang:"Greek"}], evolution:["gala (Grk)","galaxias kyklos","galaxia (Lat)","galaxy"], relatives:["galactic","lactic","lactose","lettuce"], funFact:"In myth, baby Heracles was pushed from Hera's breast, spraying milk across the sky â€” creating the Milky Way. Greek gala and Latin lac are related, linking 'galaxy' and 'lactose.'" },
  { word:"amnesty", def:"An official pardon for offenses", pos:"noun", ipa:"/ËˆÃ¦m.nÉ™.sti/", origin:"Greek", year:"1570s", etymology:"From Greek amnÄ“stia â€” 'forgetfulness, oblivion'", roots:[{part:"a-",meaning:"not, without",lang:"Greek"},{part:"mnÄ“stis",meaning:"remembrance",lang:"Greek"}], evolution:["amnÄ“stia (Grk)","amnestia (Lat)","amnistie (Fr)","amnesty"], relatives:["amnesia","mnemonic","Mnemosyne"], funFact:"Amnesty and amnesia are siblings â€” both mean 'forgetting.' Mnemosyne (Memory) was mother of the nine Muses â€” art springs from remembering." },
  { word:"inaugurate", def:"To begin formally or install in office", pos:"verb", ipa:"/ÉªËˆnÉ”Ë.É¡jÊŠ.reÉªt/", origin:"Latin", year:"1600s", etymology:"From Latin inaugurare â€” 'to take omens from bird flight'", roots:[{part:"in-",meaning:"into",lang:"Latin"},{part:"augurare",meaning:"to divine from birds",lang:"Latin"}], evolution:["augur (Lat)","inaugurare (Lat)","inaugurer (Fr)","inaugurate"], relatives:["augur","augment","august"], funFact:"Romans read bird flight patterns before any important undertaking. Every presidential inauguration etymologically involves checking if the birds say it's okay." },
  { word:"sincere", def:"Free from pretense; genuine", pos:"adj", ipa:"/sÉªnËˆsÉªÉ™r/", origin:"Latin", year:"1530s", etymology:"From Latin sincerus â€” 'clean, pure, whole'", roots:[{part:"sin-",meaning:"one",lang:"Latin"},{part:"-cerus",meaning:"growth",lang:"Latin"}], evolution:["sincerus (Lat)","sincÃ¨re (Fr)","sincere"], relatives:["sincerity","sincerely"], funFact:"Folk etymology claims it's from 'sine cera' (without wax) â€” sculptors hiding marble flaws. Almost certainly false but wonderfully persistent." },
  { word:"ubiquitous", def:"Found everywhere", pos:"adj", ipa:"/juËËˆbÉªk.wÉª.tÉ™s/", origin:"Latin", year:"1830s", etymology:"From Latin ubique â€” 'everywhere'", roots:[{part:"ubi",meaning:"where",lang:"Latin"},{part:"-que",meaning:"universalizing suffix",lang:"Latin"}], evolution:["ubique (Lat)","ubiquitas (Med Lat)","ubiquitous"], relatives:["ubiquity","ubiquitously"], funFact:"In theology, 'ubiquity' described God's omnipresence. Entered everyday English in the 19th century when mass production made goods truly 'everywhere.'" },
  { word:"hippopotamus", def:"A large African semi-aquatic mammal", pos:"noun", ipa:"/ËŒhÉªp.É™ËˆpÉ’t.É™.mÉ™s/", origin:"Greek", year:"1560s", etymology:"From Greek hippopotamos â€” 'river horse'", roots:[{part:"hippos",meaning:"horse",lang:"Greek"},{part:"potamos",meaning:"river",lang:"Greek"}], evolution:["hippos + potamos (Grk)","hippopotamus (Lat)","hippopotamus"], relatives:["hippodrome","Philip ('horse-lover')","Mesopotamia ('between rivers')","potable"], funFact:"The name 'Philip' shares the hippo- root â€” it means 'lover of horses.' Mesopotamia shares potamos â€” 'between rivers.' A hippodrome is where horses run." },
  { word:"decimate", def:"To destroy a large proportion of", pos:"verb", ipa:"/ËˆdÉ›s.Éª.meÉªt/", origin:"Latin", year:"1600s", etymology:"From Latin decimare â€” 'to take a tenth'", roots:[{part:"decimus",meaning:"tenth",lang:"Latin"},{part:"-are",meaning:"to do",lang:"Latin"}], evolution:["decem (Lat,'ten')","decimare (Lat)","dÃ©cimer (Fr)","decimate"], relatives:["decimal","December","decade","dime"], funFact:"Roman military punishment: kill every tenth soldier by lot. The word meant exactly 10% destruction. December was the 10th month before January and February were added." },
  { word:"cynic", def:"A person who distrusts human sincerity", pos:"noun", ipa:"/ËˆsÉªn.Éªk/", origin:"Greek", year:"1540s", etymology:"From Greek kynikos â€” 'dog-like'", roots:[{part:"kyon",meaning:"dog",lang:"Greek"}], evolution:["kyon (Grk)","kynikos (Grk)","cynicus (Lat)","cynic"], relatives:["cynical","canine","kennel"], funFact:"The philosopher Diogenes lived like a dog â€” sleeping in a barrel, eating scraps, performing bodily functions in public. His followers were called 'dog philosophers.' Same root gives us 'canine.'" },
  { word:"enthusiasm", def:"Intense enjoyment or eager interest", pos:"noun", ipa:"/ÉªnËˆÎ¸juË.zi.Ã¦z.É™m/", origin:"Greek", year:"1600s", etymology:"From Greek enthousiasmos â€” 'divine possession, to be inspired by a god'", roots:[{part:"en-",meaning:"in",lang:"Greek"},{part:"theos",meaning:"god",lang:"Greek"}], evolution:["en + theos (Grk)","enthousiasmos","enthusiasm"], relatives:["enthusiast","theology","theocracy","atheist","pantheon"], funFact:"Originally meant 'possessed by a god.' Being enthusiastic was literally having a deity inside you. Initially used negatively â€” religious fanatics were called 'enthusiasts.'" },
  { word:"diploma", def:"A certificate of academic achievement", pos:"noun", ipa:"/dÉªËˆploÊŠ.mÉ™/", origin:"Greek", year:"1640s", etymology:"From Greek diploma â€” 'a paper folded double'", roots:[{part:"diploun",meaning:"to fold double",lang:"Greek"},{part:"di-",meaning:"two",lang:"Greek"}], evolution:["diploun (Grk)","diploma (Lat)","diploma (Eng)"], relatives:["diplomat","diplomacy","diploid","double"], funFact:"Roman passports and official documents were folded in two and sealed. The word for these folded papers became 'diploma.' A 'diplomat' is literally someone who carries folded papers." },
  { word:"rival", def:"A person competing with another", pos:"noun", ipa:"/ËˆraÉª.vÉ™l/", origin:"Latin", year:"1570s", etymology:"From Latin rivalis â€” 'one using the same stream as another'", roots:[{part:"rivus",meaning:"stream, brook",lang:"Latin"}], evolution:["rivus (Lat)","rivalis (Lat)","rival (Fr)","rival"], relatives:["river","rivulet","derive","arrive"], funFact:"Neighbors sharing a stream (rivus) inevitably argued over water rights, making them 'rivals.' The concept of competition literally flows from disputes over water." },
  { word:"calculate", def:"To determine by mathematical process", pos:"verb", ipa:"/ËˆkÃ¦l.kjÊŠ.leÉªt/", origin:"Latin", year:"1560s", etymology:"From Latin calculare â€” 'to reckon by means of pebbles'", roots:[{part:"calculus",meaning:"small stone, pebble",lang:"Latin"}], evolution:["calx (Lat,'limestone')","calculus (Lat,'pebble')","calculare","calculate"], relatives:["calculus","calcium","chalk"], funFact:"Romans used small stones (calculi) on counting boards â€” an abacus made of pebbles. Higher math is still called 'calculus.' And 'calcium' is theite mineral in those stones." },
  { word:"Antarctica", def:"The southernmost continent", pos:"noun", ipa:"/Ã¦nËˆtÉ‘Ërk.tÉª.kÉ™/", origin:"Greek", year:"1300s", etymology:"From Greek antarktikos â€” 'opposite the bear (constellation)'", roots:[{part:"anti-",meaning:"opposite",lang:"Greek"},{part:"arktos",meaning:"bear",lang:"Greek"}], evolution:["arktos (Grk,'bear')","arktikos (Grk)","antarktikos","Antarctica"], relatives:["Arctic","Ursa Major","Arthur (possibly)"], funFact:"The Arctic is named for the Great Bear constellation (Ursa Major) visible in the north. Antarctica is 'anti-Arctic' â€” opposite the bear. The name King Arthur may also derive from arktos." },
  { word:"vaccine", def:"A substance stimulating immunity", pos:"noun", ipa:"/ËˆvÃ¦k.siËn/", origin:"Latin", year:"1799", etymology:"From Latin vaccinus â€” 'pertaining to cows'", roots:[{part:"vacca",meaning:"cow",lang:"Latin"},{part:"-inus",meaning:"of the nature of",lang:"Latin"}], evolution:["vacca (Lat)","vaccinus","vaccine"], relatives:["vaccinate","vaccination","vaquero"], funFact:"Jenner noticed milkmaids who caught cowpox never got smallpox. 'Vaccine' literally means 'cow stuff.'" },
  { word:"helicopter", def:"An aircraft with rotating blades", pos:"noun", ipa:"/ËˆhÉ›l.ÉªËŒkÉ’p.tÉ™r/", origin:"Greek", year:"1861", etymology:"From Greek helix + pteron â€” 'spiral wing'", roots:[{part:"helix",meaning:"spiral",lang:"Greek"},{part:"pteron",meaning:"wing",lang:"Greek"}], evolution:["helix + pteron (Grk)","hÃ©licoptÃ¨re (Fr)","helicopter"], relatives:["helix","pterodactyl","pteranodon","archaeopteryx","diptera"], funFact:"Most people split it as 'heli-copter' but etymologically it's 'helico-pter' â€” spiral wing. Pteron also gives us pterodactyl ('wing finger') and all the -ptera insect orders." },
  { word:"dandelion", def:"A yellow wildflower with toothed leaves", pos:"noun", ipa:"/ËˆdÃ¦n.dÉªËŒlaÉª.É™n/", origin:"French", year:"1300s", etymology:"From French dent de lion â€” 'lion's tooth'", roots:[{part:"dent",meaning:"tooth",lang:"French/Latin"},{part:"de",meaning:"of",lang:"French"},{part:"lion",meaning:"lion",lang:"French/Latin"}], evolution:["dens leonis (Lat)","dent de lion (Fr)","dandelion"], relatives:["dental","dentist","trident","Leo","lion"], funFact:"Named for the jagged, tooth-shaped leaves, not the flower. In nearly every European language it references teeth: German LÃ¶wenzahn ('lion tooth'), Italian dente di leone." },
  { word:"checkmate", def:"A winning position in chess", pos:"noun", ipa:"/ËˆtÊƒÉ›k.meÉªt/", origin:"Persian/Arabic", year:"1300s", etymology:"From Persian shÄh mÄt â€” 'the king is dead/helpless'", roots:[{part:"shÄh",meaning:"king",lang:"Persian"},{part:"mÄt",meaning:"dead, helpless",lang:"Arabic"}], evolution:["shÄh mÄt (Persian)","escec mat (OFr)","checkmate"], relatives:["check","chess","shah","exchequer"], funFact:"Chess traveled from India to Persia to Arabia to Europe. 'Check' itself comes from shÄh (king). The Exchequer (British treasury) is named for a checkered counting cloth." }
];

// Deduplicate
const seen = new Set();
const WORDS = WORD_BANK.filter(w => { if (seen.has(w.word)) return false; seen.add(w.word); return true; });

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UTILITIES
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const getDayKey = () => { const d = new Date(); return `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`; };
const getPrevDayKey = () => { const d = new Date(); d.setDate(d.getDate()-1); return `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`; };

const seededRng = (seed) => {
  let s = 0;
  for (let i = 0; i < seed.length; i++) s = ((s << 5) - s + seed.charCodeAt(i)) | 0;
  return () => { s = (s * 16807) % 2147483647; return (s & 0x7fffffff) / 0x7fffffff; };
};

const shuffle = (arr, rng) => {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(rng() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; }
  return a;
};

const speak = (text) => {
  if (!window.speechSynthesis) return;
  window.speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text);
  u.rate = 0.8; window.speechSynthesis.speak(u);
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SOUND FX (Web Audio API)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let audioCtx = null;
const getAudio = () => { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return audioCtx; };

const playSound = (type) => {
  try {
    const ctx = getAudio();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    gain.gain.value = 0.12;

    if (type === "correct") {
      osc.type = "sine"; osc.frequency.value = 520;
      osc.frequency.setValueAtTime(520, ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(780, ctx.currentTime + 0.08);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.2);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.2);
    } else if (type === "wrong") {
      osc.type = "sawtooth"; osc.frequency.value = 180;
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.25);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.25);
    } else if (type === "combo") {
      osc.type = "sine"; osc.frequency.value = 600;
      osc.frequency.setValueAtTime(600, ctx.currentTime);
      osc.frequency.linearRampToValueAtTime(1200, ctx.currentTime + 0.15);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.3);
    } else if (type === "levelup") {
      [0, 0.1, 0.2].forEach((t, i) => {
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        o.type = "sine"; o.frequency.value = 500 + i * 200; g.gain.value = 0.1;
        g.gain.linearRampToValueAtTime(0, ctx.currentTime + t + 0.15);
        o.start(ctx.currentTime + t); o.stop(ctx.currentTime + t + 0.15);
      });
    } else if (type === "tick") {
      osc.type = "sine"; osc.frequency.value = 900;
      gain.gain.value = 0.06;
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.04);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.04);
    } else if (type === "timeup") {
      osc.type = "square"; osc.frequency.value = 300;
      osc.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.4);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.4);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.4);

    } else if (type === "learn_start") {
      // Warm drone triad â€” A2 + E3 + A3, slow swell, meditative
      [110, 165, 220].forEach((freq) => {
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        o.type = "sine"; o.frequency.value = freq;
        g.gain.setValueAtTime(0, ctx.currentTime);
        g.gain.linearRampToValueAtTime(0.052, ctx.currentTime + 0.4);
        g.gain.linearRampToValueAtTime(0.032, ctx.currentTime + 0.75);
        g.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.2);
        o.start(ctx.currentTime); o.stop(ctx.currentTime + 1.2);
      });
    } else if (type === "learn_card") {
      // Soft papery page-turn flick
      osc.type = "sine"; osc.frequency.value = 300;
      osc.frequency.linearRampToValueAtTime(460, ctx.currentTime + 0.055);
      gain.gain.value = 0.042;
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.085);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.085);

    } else if (type === "quiz_start") {
      // Ascending C-major arpeggio: C4 â†’ E4 â†’ G4 â†’ C5
      [262, 330, 392, 524].forEach((freq, i) => {
        const t = ctx.currentTime + i * 0.09;
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        o.type = "sine"; o.frequency.value = freq;
        g.gain.setValueAtTime(i === 3 ? 0.1 : 0.07, t);
        g.gain.linearRampToValueAtTime(0, t + (i === 3 ? 0.28 : 0.14));
        o.start(t); o.stop(t + 0.3);
      });

    } else if (type === "speed_go") {
      // Energetic rising sawtooth sweep then a bright ping
      osc.type = "sawtooth"; osc.frequency.value = 150;
      osc.frequency.linearRampToValueAtTime(700, ctx.currentTime + 0.16);
      gain.gain.value = 0.07;
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.2);
      osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.2);
      // Bright ping on top
      const o2 = ctx.createOscillator(); const g2 = ctx.createGain();
      o2.connect(g2); g2.connect(ctx.destination);
      o2.type = "sine"; o2.frequency.value = 1046;
      g2.gain.setValueAtTime(0.09, ctx.currentTime + 0.14);
      g2.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.32);
      o2.start(ctx.currentTime + 0.14); o2.stop(ctx.currentTime + 0.32);

    } else if (type === "results") {
      // Warm sustained A-major chord â€” A3 C#4 E4 A4 â€” gentle swell
      [220, 277, 330, 440].forEach((freq) => {
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        o.type = "sine"; o.frequency.value = freq;
        g.gain.setValueAtTime(0, ctx.currentTime);
        g.gain.linearRampToValueAtTime(0.052, ctx.currentTime + 0.3);
        g.gain.linearRampToValueAtTime(0.038, ctx.currentTime + 0.9);
        g.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.5);
        o.start(ctx.currentTime); o.stop(ctx.currentTime + 1.5);
      });
    }
  } catch (e) {}
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   XP & LEVEL SYSTEM
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const XP_PER_CORRECT = 10;
const XP_COMBO_BONUS = 5;    // per combo level
const XP_SPEED_BONUS = 15;   // for speed round correct
const XP_PERFECT_BONUS = 50;

const xpForLevel = (lvl) => 50 + (lvl - 1) * 30;

const TITLES = [
  "Novice Etymologist", "Word Apprentice", "Root Seeker", "Lexicon Scout",
  "Language Archaeologist", "Etymology Adept", "Philological Scholar",
  "Word Origin Master", "Linguistic Sage", "Grandmaster Etymologist"
];

const getTitle = (level) => TITLES[Math.min(level - 1, TITLES.length - 1)];

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   QUIZ GENERATION
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const ROOT_MEANINGS_POOL = [
  "war, conflict","water, sea","fire, heat","stone, rock","love, desire","king, ruler",
  "earth, land","time, age","life, living","death, dying","light, bright","dark, shadow",
  "hand, touch","eye, sight","voice, speak","tree, wood","blood, red","wind, breath",
  "gold, wealth","child, young","field, plain","song, sing","ship, sail","fear, dread",
  "truth, real","sleep, dream","city, town","law, rule","write, mark","eat, devour"
];

const generateRounds = (todaysWords, rng) => {
  const rounds = [];
  const all = WORDS;

  todaysWords.forEach(w => {
    // 1: Root meaning
    if (w.roots.length > 0) {
      const r = w.roots[Math.floor(rng() * w.roots.length)];
      const wrongs = ROOT_MEANINGS_POOL.filter(m => m !== r.meaning);
      rounds.push({ type:"root_meaning", wordObj:w, q:`What does "${r.part}" mean?`, sub:`Root found in "${w.word}"`,
        choices: shuffle([r.meaning, ...shuffle(wrongs, rng).slice(0,3)], rng), answer: r.meaning,
        explain:`"${r.part}" = "${r.meaning}" (${r.lang})` });
    }

    // 2: Language of origin
    const origins = [...new Set(all.map(x=>x.origin))];
    rounds.push({ type:"origin", wordObj:w, q:`What language does "${w.word}" come from?`, sub:"Trace it back to its oldest root",
      choices: shuffle([w.origin, ...shuffle(origins.filter(o=>o!==w.origin), rng).slice(0,3)], rng), answer: w.origin,
      explain: w.etymology });

    // 3: Word relatives
    if (w.relatives.length >= 2) {
      const correct = w.relatives[Math.floor(rng() * w.relatives.length)];
      const unrelated = shuffle(all.filter(x=>x.word!==w.word), rng).flatMap(x=>x.relatives).filter(r=>!w.relatives.includes(r));
      if (unrelated.length >= 3) {
        rounds.push({ type:"relatives", wordObj:w, q:`Which word is an etymological cousin of "${w.word}"?`, sub:"They share an ancient root",
          choices: shuffle([correct, ...shuffle(unrelated, rng).slice(0,3)], rng), answer: correct,
          explain:`Both trace back to: ${w.roots.map(r=>r.part+' ('+r.meaning+')').join(', ')}` });
      }
    }

    // 4: Fun fact / True etymology
    const wrongEtys = shuffle(all.filter(x=>x.word!==w.word), rng).slice(0,3).map(x => x.etymology);
    rounds.push({ type:"etymology_match", wordObj:w, q:`Which origin story is correct for "${w.word}"?`, sub:"Pick the true etymology",
      choices: shuffle([w.etymology, ...wrongEtys], rng).slice(0,4), answer: w.etymology,
      explain: w.funFact });

    // 5: Reverse â€” given the etymology, name the word
    const wrongWords = shuffle(all.filter(x=>x.word!==w.word), rng).slice(0,3).map(x=>x.word);
    rounds.push({ type:"reverse", wordObj:w, q:`Which word comes from: "${w.etymology}"?`, sub:"Match the origin to the word",
      choices: shuffle([w.word, ...wrongWords], rng), answer: w.word, explain: w.funFact });

    // 6: Fun Fact Match â€” given the fun fact, name the word
    const wrongWordsFf = shuffle(all.filter(x=>x.word!==w.word), rng).slice(0,3).map(x=>x.word);
    rounds.push({ type:"funfact_match", wordObj:w,
      q: w.funFact,
      sub:"Which word does this describe?",
      choices: shuffle([w.word, ...wrongWordsFf], rng), answer: w.word,
      explain:`${w.etymology} â€” ${w.def}` });
  });

  return shuffle(rounds, rng).slice(0, 20);
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STORAGE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const SKEY = "wordspark-ety-v2";
const load = async () => { try { const r = await window.storage.get(SKEY); return r ? JSON.parse(r.value) : null; } catch { return null; } };
const save = async (s) => { try { await window.storage.set(SKEY, JSON.stringify(s)); } catch {} };
const INIT_STATE = { dayKey:null, streak:0, bestStreak:0, totalWords:0, completedToday:false, todayScore:0, todayTotal:0, todayXP:0, xp:0, level:1, lastDay:null, seenIdx:[], soundOn:true };

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LANG ICONS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const LANG_ICONS = {"Greek":"ðŸ›ï¸","Latin":"ðŸ›ï¸","Arabic":"ðŸ•Œ","Arabic/Persian":"ðŸ•Œ","Persian/Arabic":"ðŸ•Œ","Italian":"ðŸ‡®ðŸ‡¹","Italian/Greek":"ðŸ‡®ðŸ‡¹","Old French":"âšœï¸","French":"âšœï¸","English (coined)":"ðŸ‡¬ðŸ‡§","English":"ðŸ‡¬ðŸ‡§","Old English":"ðŸ—¡ï¸","Greek myth":"ðŸ›ï¸","Greek (coined)":"ðŸ›ï¸","Persian":"ðŸ•Œ","Persian/Arabic":"ðŸ•Œ"};
const langIcon = l => LANG_ICONS[l] || "ðŸ“œ";

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PARTICLE SYSTEM
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const Particles = ({ active, type }) => {
  const canvasRef = useRef(null);
  const particles = useRef([]);
  const animRef = useRef(null);

  useEffect(() => {
    if (!active || !canvasRef.current) return;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
    canvas.width = canvas.offsetWidth * 2;
    canvas.height = canvas.offsetHeight * 2;
    ctx.scale(2, 2);
    const W = canvas.offsetWidth, H = canvas.offsetHeight;

    const colors = type === "correct"
      ? ["#c4a46a","#e8a849","#7eb87e","#d4b87a","#fff"]
      : type === "combo" ? ["#ff6b6b","#ffd93d","#6bcb77","#4d96ff","#ff6b6b","#fff"]
      : type === "levelup" ? ["#ffd700","#ff6b00","#ff0","#fff","#ffd700"]
      : ["#c4a46a"];

    const count = type === "combo" ? 40 : type === "levelup" ? 60 : 20;
    particles.current = Array.from({ length: count }, () => ({
      x: W / 2 + (Math.random() - 0.5) * 80,
      y: H / 2,
      vx: (Math.random() - 0.5) * (type === "levelup" ? 12 : 8),
      vy: -Math.random() * (type === "levelup" ? 14 : 10) - 2,
      size: Math.random() * 4 + 2,
      color: colors[Math.floor(Math.random() * colors.length)],
      life: 1,
      decay: 0.01 + Math.random() * 0.02,
      gravity: 0.15
    }));

    const animate = () => {
      ctx.clearRect(0, 0, W, H);
      let alive = false;
      particles.current.forEach(p => {
        if (p.life <= 0) return;
        alive = true;
        p.x += p.vx; p.y += p.vy; p.vy += p.gravity; p.life -= p.decay;
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
      });
      ctx.globalAlpha = 1;
      if (alive) animRef.current = requestAnimationFrame(animate);
    };
    animate();
    return () => { if (animRef.current) cancelAnimationFrame(animRef.current); };
  }, [active, type]);

  if (!active) return null;
  return <canvas ref={canvasRef} style={{ position:"absolute", inset:0, pointerEvents:"none", zIndex:50 }} />;
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   AMBIENT MUSIC ENGINE
   Foundation: bass pedal tracking Amâ†’Fâ†’Câ†’G chord progression (18s/chord)
   Layers: chord pad triad Â· structured melodic cell Â· pentatonic plucks Â·
           singing-bowl bells Â· binaural theta 4Hz Â· ASMR pink noise Â·
           shimmer shimmer Â· reverb Â· breath LFO Â· master compressor
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let droneNodes = null;
let _droneTimers = [];
const _dt = (fn, ms) => { const id = setTimeout(fn, ms); _droneTimers.push({t:"t",id}); };
const _di = (fn, ms) => { const id = setInterval(fn, ms); _droneTimers.push({t:"i",id}); return id; };

const _makeNoiseBuf = (ctx) => {
  const sz = ctx.sampleRate * 3;
  const buf = ctx.createBuffer(1, sz, ctx.sampleRate);
  const d = buf.getChannelData(0);
  let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0;
  for (let i=0;i<sz;i++){
    const w=Math.random()*2-1;
    b0=.99886*b0+w*.0555179;b1=.99332*b1+w*.0750759;
    b2=.9690*b2+w*.1538520;b3=.8665*b3+w*.3104856;
    b4=.5500*b4+w*.5329522;b5=-.7616*b5-w*.0168980;
    d[i]=(b0+b1+b2+b3+b4+b5+w*.5362)*.13;
  }
  return buf;
};

// Amâ†’Fâ†’Câ†’G progression: [bass, pad1, pad2, pad3] all in Hz
const CHORD_PROG = [
  [55,   110,   164.8, 220],   // Am â€” A2  A3  E3  A3
  [43.7, 87.3,  130.8, 174.6], // F  â€” F2  F3  C3  F3
  [65.4, 130.8, 164.8, 196.0], // C  â€” C3  C3  E3  G3
  [49.0, 98.0,  146.8, 196.0], // G  â€” G2  G3  D3  G3
];
const CHORD_MS = 18000;
const GLIDE_S  = 6.5;

// Structured melodic cells in A minor â€” played in sequence with variation
const MEL_CELLS = [
  [220, 246.9, 261.6, 329.6, 293.7],  // A3 B3 C4 E4 D4 â€” ascending spread
  [329.6, 261.6, 246.9, 220, 261.6],  // E4 C4 B3 A3 C4 â€” falling return
  [261.6, 329.6, 293.7, 392.0, 329.6],// C4 E4 D4 G4 E4 â€” lifted arc
  [220, 261.6, 246.9, 220, 293.7],    // A3 C4 B3 A3 D4 â€” narrow contemplative
  [392.0, 329.6, 293.7, 261.6, 220],  // G4 E4 D4 C4 A3 â€” descending scale
];
const _playCell = (ctx, dst, send) => {
  if (!droneNodes) return;
  const cell = MEL_CELLS[Math.floor(Math.random() * MEL_CELLS.length)];
  let t = ctx.currentTime;
  cell.forEach((freq, i) => {
    const dur = 2.6 + Math.random() * 2.4;
    const gap = dur * 0.52 + Math.random() * 1.2;
    const mo = ctx.createOscillator(); const mg = ctx.createGain();
    mo.type = "triangle"; mo.frequency.value = freq;
    const vl = ctx.createOscillator(); const vg = ctx.createGain();
    vl.type = "sine"; vl.frequency.value = 4.1 + i * 0.28;
    vg.gain.value = freq * 0.0055;
    vl.connect(vg); vg.connect(mo.frequency);
    mg.gain.setValueAtTime(0, t);
    mg.gain.linearRampToValueAtTime(0.065, t + 0.5);
    mg.gain.linearRampToValueAtTime(0.040, t + dur - 0.7);
    mg.gain.linearRampToValueAtTime(0, t + dur);
    mo.connect(mg); mg.connect(dst); send(mg);
    vl.start(t); vl.stop(t + dur + .1);
    mo.start(t); mo.stop(t + dur + .1);
    t += gap;
  });
  const total = t - ctx.currentTime;
  _dt(() => _playCell(ctx, dst, send), (total + 7 + Math.random() * 11) * 1000);
};

// Pentatonic soft pluck â€” 2-note sparkles every 4â€“9s
const A_PENTA = [220, 261.6, 293.7, 329.6, 392.0, 440, 523.3];
const _pluck = (ctx, dst, send) => {
  if (!droneNodes) return;
  [[A_PENTA[Math.floor(Math.random()*A_PENTA.length)],0],
   [A_PENTA[Math.floor(Math.random()*A_PENTA.length)],0.22]].forEach(([freq,dt])=>{
    const o=ctx.createOscillator(); const g=ctx.createGain();
    o.type="sine"; o.frequency.value=freq;
    g.gain.setValueAtTime(0, ctx.currentTime+dt);
    g.gain.linearRampToValueAtTime(0.042, ctx.currentTime+dt+0.04);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dt+3.2);
    o.connect(g); g.connect(dst); send(g);
    o.start(ctx.currentTime+dt); o.stop(ctx.currentTime+dt+3.5);
  });
  _dt(() => _pluck(ctx, dst, send), 4000 + Math.random() * 5000);
};

// Singing-bowl â€” inharmonic overtones, long sustain
const BOWL_F = [220, 293.7, 329.6, 440, 523.3, 659.3];
const _bowl = (ctx, dst, send) => {
  if (!droneNodes) return;
  const f = BOWL_F[Math.floor(Math.random()*BOWL_F.length)];
  [1, 2.756, 5.404].forEach((h,i) => {
    const o=ctx.createOscillator(); const g=ctx.createGain();
    o.type="sine"; o.frequency.value=f*h;
    g.gain.setValueAtTime(0,ctx.currentTime);
    g.gain.linearRampToValueAtTime(0.08/(i+1), ctx.currentTime+0.12);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+6.5-i*1.2);
    o.connect(g); g.connect(dst); if(i===0) send(g);
    o.start(ctx.currentTime); o.stop(ctx.currentTime+7);
  });
  _dt(() => _bowl(ctx, dst, send), 8000 + Math.random() * 14000);
};

const startDroneEngine = () => {
  if (droneNodes) return;
  try {
    const ctx = getAudio();
    if (ctx.state === "suspended") ctx.resume();
    const t = ctx.currentTime;

    // Master bus
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value=-10; comp.ratio.value=3.5;
    comp.knee.value=10; comp.attack.value=0.05; comp.release.value=1.2;
    const master = ctx.createGain();
    master.gain.setValueAtTime(0, t);
    comp.connect(master); master.connect(ctx.destination);

    // Reverb bus
    const revDly = ctx.createDelay(0.9); revDly.delayTime.value=0.42;
    const revFB = ctx.createGain(); revFB.gain.value=0.44;
    const revLP = ctx.createBiquadFilter(); revLP.type="lowpass"; revLP.frequency.value=1600;
    const revOut = ctx.createGain(); revOut.gain.value=0.30;
    revDly.connect(revLP); revLP.connect(revFB); revFB.connect(revDly);
    revDly.connect(revOut); revOut.connect(comp);
    const send = (g) => { const s=ctx.createGain(); s.gain.value=0.38; g.connect(s); s.connect(revDly); };

    // Bass (tracks chord root, two detuned copies for warmth)
    const bA = ctx.createOscillator(); const bAG = ctx.createGain();
    bA.type="sine"; bA.frequency.value=CHORD_PROG[0][0]; bA.detune.value=-2.2;
    bAG.gain.value=0.95; bA.connect(bAG); bAG.connect(comp); send(bAG); bA.start();
    const bB = ctx.createOscillator(); const bBG = ctx.createGain();
    bB.type="sine"; bB.frequency.value=CHORD_PROG[0][0]; bB.detune.value=3.8;
    bBG.gain.value=0.48; bB.connect(bBG); bBG.connect(comp); bB.start();

    // Pad triad (triangle waves, slow organic vibrato on each)
    const makePad = (freq, det, gain) => {
      const o=ctx.createOscillator(); const g=ctx.createGain();
      o.type="triangle"; o.frequency.value=freq; o.detune.value=det;
      const vl=ctx.createOscillator(); const vg=ctx.createGain();
      vl.type="sine"; vl.frequency.value=0.14+Math.random()*0.08;
      vg.gain.value=freq*0.007;
      vl.connect(vg); vg.connect(o.detune); vl.start();
      g.gain.value=gain;
      o.connect(g); g.connect(comp); send(g); o.start();
      return {o, vl};
    };
    const p1=makePad(CHORD_PROG[0][1],-2.8,0.50);
    const p2=makePad(CHORD_PROG[0][2], 2.3,0.32);
    const p3=makePad(CHORD_PROG[0][3],-1.2,0.20);

    // Chord progression scheduler
    let cIdx=0;
    _di(() => {
      if (!droneNodes) return;
      cIdx=(cIdx+1)%CHORD_PROG.length;
      const ch=CHORD_PROG[cIdx]; const now=ctx.currentTime;
      bA.frequency.linearRampToValueAtTime(ch[0], now+GLIDE_S);
      bB.frequency.linearRampToValueAtTime(ch[0], now+GLIDE_S);
      p1.o.frequency.linearRampToValueAtTime(ch[1], now+GLIDE_S);
      p2.o.frequency.linearRampToValueAtTime(ch[2], now+GLIDE_S);
      p3.o.frequency.linearRampToValueAtTime(ch[3], now+GLIDE_S);
    }, CHORD_MS);

    // Binaural theta 4Hz focus beat (432 + 436)
    const bn1=ctx.createOscillator(); const bn1G=ctx.createGain();
    bn1.type="sine"; bn1.frequency.value=432; bn1G.gain.value=0.072;
    bn1.connect(bn1G); bn1G.connect(comp); bn1.start();
    const bn2=ctx.createOscillator(); const bn2G=ctx.createGain();
    bn2.type="sine"; bn2.frequency.value=436; bn2G.gain.value=0.072;
    bn2.connect(bn2G); bn2G.connect(comp); bn2.start();

    // High shimmer A5 with slow 53s LFO
    const sh=ctx.createOscillator(); const shG=ctx.createGain();
    sh.type="sine"; sh.frequency.value=880; sh.detune.value=4.8;
    shG.gain.value=0;
    sh.connect(shG); shG.connect(comp); send(shG); sh.start();
    const shLFO=ctx.createOscillator(); const shLFOG=ctx.createGain();
    shLFO.type="sine"; shLFO.frequency.value=0.019; shLFOG.gain.value=0.032;
    shLFO.connect(shLFOG); shLFOG.connect(shG.gain); shLFO.start();

    // Breath LFO on master (18s inhale/exhale)
    const brLFO=ctx.createOscillator(); const brG=ctx.createGain();
    brLFO.type="sine"; brLFO.frequency.value=0.056; brG.gain.value=0.054;
    brLFO.connect(brG); brG.connect(master.gain); brLFO.start();

    // Pink-noise ASMR texture
    const ns=ctx.createBufferSource(); ns.buffer=_makeNoiseBuf(ctx); ns.loop=true;
    const nbp=ctx.createBiquadFilter(); nbp.type="bandpass"; nbp.frequency.value=440; nbp.Q.value=0.30;
    const nlp=ctx.createBiquadFilter(); nlp.type="lowpass"; nlp.frequency.value=1100;
    const ng=ctx.createGain(); ng.gain.value=0.036;
    ns.connect(nbp); nbp.connect(nlp); nlp.connect(ng); ng.connect(comp); send(ng); ns.start();

    // Scheduled layers
    _bowl(ctx, comp, send);
    _dt(() => _playCell(ctx, comp, send), 6000);
    _dt(() => _pluck(ctx, comp, send), 13000);

    // Fade in
    master.gain.cancelScheduledValues(t);
    master.gain.setValueAtTime(0, t);
    master.gain.linearRampToValueAtTime(0.52, t+7.0);

    droneNodes = {
      ctx, master, comp,
      oscs: [bA, bB, p1.o, p1.vl, p2.o, p2.vl, p3.o, p3.vl,
             bn1, bn2, sh, shLFO, brLFO],
      noiseSrc: ns
    };
  } catch(e) { console.error("Drone:", e); }
};

const stopDroneEngine = (instant=false) => {
  _droneTimers.forEach(({t,id}) => t==="t" ? clearTimeout(id) : clearInterval(id));
  _droneTimers = [];
  if (!droneNodes) return;
  try {
    const {ctx, master, oscs, noiseSrc} = droneNodes;
    const fade = instant ? 0.08 : 2.8;
    master.gain.cancelScheduledValues(ctx.currentTime);
    master.gain.setValueAtTime(master.gain.value, ctx.currentTime);
    master.gain.linearRampToValueAtTime(0, ctx.currentTime+fade);
    setTimeout(() => {
      oscs.forEach(o => { try{o.stop();}catch(e){} });
      try{noiseSrc.stop();}catch(e){}
    }, (fade+0.2)*1000);
  } catch(e) {}
  droneNodes = null;
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LEVEL GLYPHS â€” 10 unique emblems, each level visually distinct
   L1: Seed (single point + orbit)          L2: Duality (vesica piscis)
   L3: Trinity (triangle portal)            L4: Compass (double square star)
   L5: Pentagram (5-star)                   L6: Hexagram (Star of David)
   L7: Septagram (7-fold star)              L8: Octagram mandala
   L9: Enneagram (9-fold wheel)             L10: Metatron (full mandala)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const LevelGlyph = ({ level, xpPct, size = 200 }) => {
  const svgRef = useRef(null);
  const frameRef = useRef(null);

  useEffect(() => {
    const el = svgRef.current;
    if (!el) return;
    let rot = 0;
    const tick = () => {
      rot += 0.0025;
      el.querySelectorAll("[data-spin]").forEach(g => {
        const dir = g.dataset.spin === "cw" ? 1 : -1;
        const speed = parseFloat(g.dataset.speed || "1");
        g.style.transform = `rotate(${rot * dir * speed}rad)`;
      });
      frameRef.current = requestAnimationFrame(tick);
    };
    frameRef.current = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(frameRef.current);
  }, [level]);

  const C = size / 2;
  const R = C - 12;

  // Color tokens
  const gold  = "rgba(196,164,106,0.90)";
  const goldD = "rgba(196,164,106,0.22)";
  const amb   = "rgba(232,168,73,0.70)";
  const ambD  = "rgba(232,168,73,0.18)";
  const glow  = "rgba(232,168,73,0.35)";

  // Helpers
  const pt = (cx, cy, r, a) => [cx + r*Math.cos(a), cy + r*Math.sin(a)];
  const poly = (cx, cy, r, n, off=0) =>
    Array.from({length:n},(_,i) => pt(cx,cy,r,(i*2*Math.PI/n)+off)).map(p=>p.join(",")).join(" ");
  const star = (cx, cy, ro, ri, n, off=0) =>
    Array.from({length:n*2},(_,i) => {
      const r2 = i%2===0?ro:ri;
      return pt(cx,cy,r2,(i*Math.PI/n)+off).join(",");
    }).join(" ");

  // XP ring (common to all levels)
  const circ = 2*Math.PI*R;
  const dash = circ*(1 - xpPct/100);
  const XpRing = () => (
    <g>
      <circle cx={C} cy={C} r={R} fill="none" stroke={goldD} strokeWidth="2"/>
      <circle cx={C} cy={C} r={R} fill="none" stroke={amb} strokeWidth="2.5"
        strokeDasharray={circ} strokeDashoffset={dash} strokeLinecap="round"
        transform={`rotate(-90 ${C} ${C})`}
        style={{transition:"stroke-dashoffset .8s ease",filter:`drop-shadow(0 0 5px ${glow})`}}/>
    </g>
  );
  const Center = ({n}) => (
    <>
      <text x={C} y={C-5} textAnchor="middle"
        fontFamily="'Cormorant Garamond',serif" fontSize={R*0.36} fontWeight="700"
        fill="rgba(196,164,106,0.95)" letterSpacing="-1">{n}</text>
      <text x={C} y={C+14} textAnchor="middle"
        fontFamily="'Outfit',sans-serif" fontSize="8" fontWeight="500"
        fill="rgba(196,164,106,0.40)" letterSpacing="2">LEVEL</text>
    </>
  );

  const defs = (
    <defs>
      <radialGradient id="rg" cx="50%" cy="50%" r="50%">
        <stop offset="0%" stopColor={ambD}/>
        <stop offset="100%" stopColor="transparent"/>
      </radialGradient>
      <filter id="gf" x="-30%" y="-30%" width="160%" height="160%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="2.5" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <filter id="gf2" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
  );

  const base = {overflow:"visible", display:"block", margin:"0 auto"};

  // â”€â”€ L1: SEED â€” a single luminous point with two orbiting rings â”€â”€
  if (level === 1) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.6" style={{transformOrigin:`${C}px ${C}px`}}>
        <circle cx={C} cy={C} r={R*0.52} fill="none" stroke={goldD} strokeWidth="1" strokeDasharray="4 8"/>
      </g>
      <g data-spin="ccw" data-speed="1.0" style={{transformOrigin:`${C}px ${C}px`}}>
        <circle cx={C+R*0.28} cy={C} r={5} fill={amb} filter="url(#gf)"/>
      </g>
      <circle cx={C} cy={C} r={R*0.22} fill="none" stroke={goldD} strokeWidth="1"/>
      <circle cx={C} cy={C} r={7} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={3} fill={gold}/>
      <Center n={1}/>
    </svg>
  );

  // â”€â”€ L2: DUALITY â€” vesica piscis, two interlocking circles â”€â”€
  if (level === 2) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.4" style={{transformOrigin:`${C}px ${C}px`}}>
        <circle cx={C-R*0.22} cy={C} r={R*0.44} fill="none" stroke={goldD} strokeWidth="1.2"/>
        <circle cx={C+R*0.22} cy={C} r={R*0.44} fill="none" stroke={goldD} strokeWidth="1.2"/>
      </g>
      <circle cx={C-R*0.22} cy={C} r={R*0.44} fill="none" stroke={gold} strokeWidth="1.5" filter="url(#gf)" opacity="0.6"/>
      <circle cx={C+R*0.22} cy={C} r={R*0.44} fill="none" stroke={gold} strokeWidth="1.5" filter="url(#gf)" opacity="0.6"/>
      <g data-spin="ccw" data-speed="0.8" style={{transformOrigin:`${C}px ${C}px`}}>
        <line x1={C-R*0.6} y1={C} x2={C+R*0.6} y2={C} stroke={goldD} strokeWidth="0.8"/>
        <circle cx={C-R*0.38} cy={C} r={3.5} fill={amb}/>
        <circle cx={C+R*0.38} cy={C} r={3.5} fill={amb}/>
      </g>
      <circle cx={C} cy={C} r={4} fill={amb} filter="url(#gf2)"/>
      <Center n={2}/>
    </svg>
  );

  // â”€â”€ L3: TRINITY â€” triangle portal with inner triangle â”€â”€
  if (level === 3) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.5" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.82,3,-Math.PI/2)} fill="none" stroke={goldD} strokeWidth="1"/>
      </g>
      <polygon points={poly(C,C,R*0.65,3,-Math.PI/2)} fill="none" stroke={gold} strokeWidth="1.8" filter="url(#gf)"/>
      <g data-spin="ccw" data-speed="0.9" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.38,3,Math.PI/6)} fill={ambD} stroke={amb} strokeWidth="1.2" filter="url(#gf)"/>
      </g>
      {/* Vertices */}
      {[0,1,2].map(i => {
        const a = -Math.PI/2 + i*2*Math.PI/3;
        const [x,y] = pt(C,C,R*0.65,a);
        return <circle key={i} cx={x} cy={y} r={4} fill={amb} filter="url(#gf)"/>;
      })}
      <circle cx={C} cy={C} r={5} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={2.5} fill={gold}/>
      <Center n={3}/>
    </svg>
  );

  // â”€â”€ L4: COMPASS STAR â€” overlapping square + rotated square (8-pointed star) â”€â”€
  if (level === 4) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.4" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.78,4,0)} fill="none" stroke={goldD} strokeWidth="1"/>
        <polygon points={poly(C,C,R*0.78,4,Math.PI/4)} fill="none" stroke={goldD} strokeWidth="1"/>
      </g>
      <polygon points={star(C,C,R*0.60,R*0.28,8,0)} fill={ambD} stroke={gold} strokeWidth="1.5" filter="url(#gf)"/>
      <g data-spin="ccw" data-speed="1.2" style={{transformOrigin:`${C}px ${C}px`}}>
        <circle cx={C} cy={C} r={R*0.28} fill="none" stroke={goldD} strokeWidth="1"/>
        {[0,1,2,3].map(i => {
          const a = i*Math.PI/2; const [x,y]=pt(C,C,R*0.28,a);
          return <circle key={i} cx={x} cy={y} r={3} fill={amb}/>;
        })}
      </g>
      <circle cx={C} cy={C} r={6} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={2.5} fill={gold}/>
      <Center n={4}/>
    </svg>
  );

  // â”€â”€ L5: PENTAGRAM â€” 5-star with inner pentagon â”€â”€
  if (level === 5) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.35" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.82,5,-Math.PI/2)} fill="none" stroke={goldD} strokeWidth="1"/>
      </g>
      <polygon points={star(C,C,R*0.65,R*0.27,5,-Math.PI/2)} fill="rgba(196,164,106,0.06)" stroke={gold} strokeWidth="1.8" filter="url(#gf)"/>
      <g data-spin="ccw" data-speed="0.7" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.30,5,Math.PI/10)} fill={ambD} stroke={amb} strokeWidth="1.2" filter="url(#gf)"/>
      </g>
      {/* Star tips */}
      {[0,1,2,3,4].map(i => {
        const a = -Math.PI/2+i*2*Math.PI/5; const [x,y]=pt(C,C,R*0.65,a);
        return <circle key={i} cx={x} cy={y} r={3.5} fill={amb} filter="url(#gf)"/>;
      })}
      <circle cx={C} cy={C} r={6} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={2.5} fill={gold}/>
      <Center n={5}/>
    </svg>
  );

  // â”€â”€ L6: HEXAGRAM â€” Star of David + inner hexagon ring â”€â”€
  if (level === 6) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.3" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.80,6,0)} fill="none" stroke={goldD} strokeWidth="1"/>
      </g>
      {/* Hexagram = two triangles */}
      <polygon points={poly(C,C,R*0.60,3,-Math.PI/2)} fill="rgba(196,164,106,0.05)" stroke={gold} strokeWidth="1.6" filter="url(#gf)"/>
      <polygon points={poly(C,C,R*0.60,3,Math.PI/6)} fill="rgba(196,164,106,0.05)" stroke={gold} strokeWidth="1.6" filter="url(#gf)"/>
      <g data-spin="ccw" data-speed="0.8" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.30,6,0)} fill={ambD} stroke={amb} strokeWidth="1.4" filter="url(#gf)"/>
      </g>
      {/* 6 tip dots */}
      {[0,1,2,3,4,5].map(i => {
        const a = -Math.PI/2+i*Math.PI/3; const [x,y]=pt(C,C,R*0.60,a+(i%2?Math.PI/6:0));
        return <circle key={i} cx={x} cy={y} r={3} fill={amb} filter="url(#gf)"/>;
      })}
      <circle cx={C} cy={C} r={7} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={2.5} fill={gold}/>
      <Center n={6}/>
    </svg>
  );

  // â”€â”€ L7: SEPTAGRAM â€” 7-pointed star + inner circle web â”€â”€
  if (level === 7) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.28" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.82,7,-Math.PI/2)} fill="none" stroke={goldD} strokeWidth="1"/>
        {/* Web: every vertex connects to vertex+2 */}
        {[0,1,2,3,4,5,6].map(i => {
          const [x1,y1]=pt(C,C,R*0.82,(i*2*Math.PI/7)-Math.PI/2);
          const [x2,y2]=pt(C,C,R*0.82,((i+2)*2*Math.PI/7)-Math.PI/2);
          return <line key={i} x1={x1} y1={y1} x2={x2} y2={y2} stroke={goldD} strokeWidth="0.6"/>;
        })}
      </g>
      <polygon points={star(C,C,R*0.62,R*0.26,7,-Math.PI/2)} fill="rgba(196,164,106,0.06)" stroke={gold} strokeWidth="1.7" filter="url(#gf)"/>
      <g data-spin="ccw" data-speed="1.1" style={{transformOrigin:`${C}px ${C}px`}}>
        <circle cx={C} cy={C} r={R*0.28} fill="none" stroke={amb} strokeWidth="1" strokeDasharray="3 5"/>
      </g>
      <circle cx={C} cy={C} r={7} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={3} fill={gold}/>
      <Center n={7}/>
    </svg>
  );

  // â”€â”€ L8: OCTAGRAM MANDALA â€” 8-star + 3 concentric rings + spokes â”€â”€
  if (level === 8) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.25" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.82,8,0)} fill="none" stroke={goldD} strokeWidth="1"/>
        {[0,1,2,3,4,5,6,7].map(i => {
          const a=i*Math.PI/4; const [x,y]=pt(C,C,R*0.82,a);
          return <line key={i} x1={C} y1={C} x2={x} y2={y} stroke={goldD} strokeWidth="0.5"/>;
        })}
      </g>
      <polygon points={star(C,C,R*0.60,R*0.28,8,Math.PI/8)} fill="rgba(196,164,106,0.07)" stroke={gold} strokeWidth="1.6" filter="url(#gf)"/>
      <g data-spin="ccw" data-speed="0.9" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.40,8,Math.PI/8)} fill="none" stroke={amb} strokeWidth="1.2" filter="url(#gf)"/>
      </g>
      <g data-spin="cw" data-speed="1.8" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.22,8,0)} fill={ambD} stroke={amb} strokeWidth="1.2" filter="url(#gf)"/>
      </g>
      {/* 8 tip diamonds */}
      {[0,1,2,3,4,5,6,7].map(i=>{
        const [x,y]=pt(C,C,R*0.60,i*Math.PI/4+Math.PI/8);
        return <circle key={i} cx={x} cy={y} r={3} fill={amb} filter="url(#gf)"/>;
      })}
      <circle cx={C} cy={C} r={8} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={3} fill={gold}/>
      <Center n={8}/>
    </svg>
  );

  // â”€â”€ L9: ENNEAGRAM WHEEL â€” 9-fold geometry with 3-layer rings â”€â”€
  if (level === 9) return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      <g data-spin="cw" data-speed="0.22" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.82,9,-Math.PI/2)} fill="none" stroke={goldD} strokeWidth="1"/>
        {/* 9-web: every vertex to vertex+3 */}
        {[0,1,2,3,4,5,6,7,8].map(i=>{
          const [x1,y1]=pt(C,C,R*0.82,(i*2*Math.PI/9)-Math.PI/2);
          const [x2,y2]=pt(C,C,R*0.82,((i+3)*2*Math.PI/9)-Math.PI/2);
          return <line key={i} x1={x1} y1={y1} x2={x2} y2={y2} stroke={goldD} strokeWidth="0.6"/>;
        })}
      </g>
      <polygon points={star(C,C,R*0.62,R*0.24,9,-Math.PI/2)} fill="rgba(196,164,106,0.06)" stroke={gold} strokeWidth="1.7" filter="url(#gf)"/>
      <g data-spin="ccw" data-speed="0.7" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.42,9,Math.PI/18)} fill="none" stroke={goldD} strokeWidth="1"/>
      </g>
      <g data-spin="cw" data-speed="1.5" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.24,3,-Math.PI/2)} fill={ambD} stroke={amb} strokeWidth="1.5" filter="url(#gf)"/>
        <polygon points={poly(C,C,R*0.24,3,Math.PI/6)} fill={ambD} stroke={amb} strokeWidth="1.5" filter="url(#gf)"/>
      </g>
      {/* 9 outer dots */}
      {[0,1,2,3,4,5,6,7,8].map(i=>{
        const [x,y]=pt(C,C,R*0.62,(i*2*Math.PI/9)-Math.PI/2);
        return <circle key={i} cx={x} cy={y} r={3} fill={amb} filter="url(#gf)"/>;
      })}
      <circle cx={C} cy={C} r={9} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={3.5} fill={gold}/>
      <Center n={9}/>
    </svg>
  );

  // â”€â”€ L10: METATRON â€” 13-circle Fruit of Life + 6-fold star web (maximum) â”€â”€
  return (
    <svg ref={svgRef} width={size} height={size} viewBox={`0 0 ${size} ${size}`} style={base}>
      {defs}
      <circle cx={C} cy={C} r={R*0.72} fill="url(#rg)"/>
      <XpRing/>
      {/* Outer 12-circle flower ring (fixed) */}
      {[0,1,2,3,4,5,6,7,8,9,10,11].map(i=>{
        const a=i*Math.PI/6; const r2=R*0.62;
        const [x,y]=pt(C,C,r2,a);
        return <circle key={i} cx={x} cy={y} r={R*0.20} fill="none" stroke={goldD} strokeWidth="0.8"/>;
      })}
      {/* First slow ring */}
      <g data-spin="cw" data-speed="0.18" style={{transformOrigin:`${C}px ${C}px`}}>
        {[0,1,2,3,4,5].map(i=>{
          const a=i*Math.PI/3; const [x1,y1]=pt(C,C,R*0.62,a);
          const [x2,y2]=pt(C,C,R*0.62,a+Math.PI);
          return <line key={i} x1={x1} y1={y1} x2={x2} y2={y2} stroke={goldD} strokeWidth="0.7"/>;
        })}
        <polygon points={poly(C,C,R*0.80,6,0)} fill="none" stroke={goldD} strokeWidth="1"/>
      </g>
      {/* Hexagram double triangle */}
      <polygon points={poly(C,C,R*0.58,3,-Math.PI/2)} fill="rgba(196,164,106,0.05)" stroke={gold} strokeWidth="1.5" filter="url(#gf)"/>
      <polygon points={poly(C,C,R*0.58,3,Math.PI/6)} fill="rgba(196,164,106,0.05)" stroke={gold} strokeWidth="1.5" filter="url(#gf)"/>
      {/* Counter-rotating inner star */}
      <g data-spin="ccw" data-speed="0.6" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={star(C,C,R*0.40,R*0.18,12,0)} fill="rgba(196,164,106,0.05)" stroke={amb} strokeWidth="1.2" filter="url(#gf)"/>
      </g>
      {/* Fast inner diamond ring */}
      <g data-spin="cw" data-speed="1.4" style={{transformOrigin:`${C}px ${C}px`}}>
        <polygon points={poly(C,C,R*0.22,6,0)} fill={ambD} stroke={amb} strokeWidth="1.6" filter="url(#gf)"/>
        <polygon points={poly(C,C,R*0.22,6,Math.PI/6)} fill={ambD} stroke={amb} strokeWidth="1.0" filter="url(#gf)"/>
      </g>
      {/* 12 outer orbit dots */}
      {[0,1,2,3,4,5,6,7,8,9,10,11].map(i=>{
        const [x,y]=pt(C,C,R*0.82,i*Math.PI/6);
        return <circle key={i} cx={x} cy={y} r={2.5} fill={amb} filter="url(#gf)"/>;
      })}
      {/* 6 inner ring dots */}
      {[0,1,2,3,4,5].map(i=>{
        const [x,y]=pt(C,C,R*0.44,i*Math.PI/3+Math.PI/6);
        return <circle key={`i${i}`} cx={x} cy={y} r={3.5} fill={amb} filter="url(#gf)"/>;
      })}
      <circle cx={C} cy={C} r={12} fill={amb} filter="url(#gf2)"/>
      <circle cx={C} cy={C} r={5} fill={gold}/>
      <Center n={10}/>
    </svg>
  );
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAIN COMPONENT
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
export default function WordSparkEtymology() {
  const [st, setSt] = useState(null);
  const [phase, setPhase] = useState("loading");
  const [words, setWords] = useState([]);
  const [learnIdx, setLearnIdx] = useState(0);
  const [rounds, setRounds] = useState([]);
  const [rIdx, setRIdx] = useState(0);
  const [score, setScore] = useState(0);
  const [xpGained, setXpGained] = useState(0);
  const [combo, setCombo] = useState(0);
  const [maxCombo, setMaxCombo] = useState(0);
  const [selected, setSelected] = useState(null);
  const [showExplain, setShowExplain] = useState(false);
  const [particles, setParticles] = useState({ active: false, type: "correct" });
  const [shake, setShake] = useState(false);
  const [comboPopup, setComboPopup] = useState(null);
  const [xpPopup, setXpPopup] = useState(null);
  const [speedMode, setSpeedMode] = useState(false);
  const [speedTimer, setSpeedTimer] = useState(0);
  const [speedPhase, setSpeedPhase] = useState("off"); // off, active, done
  const [speedScore, setSpeedScore] = useState(0);
  const [speedTotal, setSpeedTotal] = useState(0);
  const [soundOn, setSoundOn] = useState(true);
  const [isBonusRound, setIsBonusRound] = useState(false);
  const [bonusRoundNum, setBonusRoundNum] = useState(0);
  const [bonusScore, setBonusScore] = useState(0);
  const [bonusTotal, setBonusTotal] = useState(0);
  const [quizScore, setQuizScore] = useState(0);
  const [quizTotal, setQuizTotal] = useState(0);
  const [profileWordFilter, setProfileWordFilter] = useState("");
  const [profileSortBy, setProfileSortBy] = useState("recent");
  const [prevPhase, setPrevPhase] = useState("welcome");
  const [expandedLexWord, setExpandedLexWord] = useState(null);
  const [scoreShared, setScoreShared] = useState(false);
  const timerRef = useRef(null);
  const styleRef = useRef(null);
  const appRef = useRef(null);

  const playFx = useCallback((type) => { if (soundOn) playSound(type); }, [soundOn]);

  // CSS injection
  useEffect(() => {
    if (!styleRef.current) {
      styleRef.current = document.createElement("style");
      styleRef.current.textContent = CSS;
      document.head.appendChild(styleRef.current);
    }
    return () => { if (styleRef.current) { styleRef.current.remove(); styleRef.current = null; } };
  }, []);

  // Ambient drone â€” start/stop with soundOn
  useEffect(() => {
    if (soundOn) startDroneEngine();
    else stopDroneEngine();
    return () => stopDroneEngine(true);
  }, [soundOn]);

  // Keyboard shortcuts: 1-4 for quiz choices
  useEffect(() => {
    const handler = (e) => {
      if (phase !== "quiz" || selected !== null || !rounds[rIdx]) return;
      const n = parseInt(e.key);
      if (n >= 1 && n <= rounds[rIdx].choices.length) {
        handleAnswer(rounds[rIdx].choices[n - 1]);
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [phase, selected, rounds, rIdx]);

  // Load
  useEffect(() => {
    (async () => {
      const saved = await load();
      const today = getDayKey();
      if (saved && saved.dayKey === today) {
        setSt(saved);
        setSoundOn(saved.soundOn !== false);
        if (saved.completedToday) { setupWords(saved, today); setPhase("results"); }
        else setPhase("welcome");
      } else {
        const prev = saved || INIT_STATE;
        const consecutive = saved && saved.lastDay === getPrevDayKey();
        const ns = { ...INIT_STATE, dayKey:today, streak:consecutive?prev.streak:0, bestStreak:prev.bestStreak||0, totalWords:prev.totalWords||0, xp:prev.xp||0, level:prev.level||1, seenIdx:prev.seenIdx||[], soundOn:prev.soundOn!==false };
        setSt(ns); setSoundOn(ns.soundOn); setPhase("welcome");
      }
    })();
  }, []);

  const setupWords = useCallback((s, today) => {
    const rng = seededRng(today + "-ety2");
    const seenSet = new Set(s.seenIdx || []);
    let avail = WORDS.map((_,i) => i).filter(i => !seenSet.has(i));
    if (avail.length < 5) avail = WORDS.map((_,i) => i);
    const picked = shuffle(avail, rng).slice(0, 5);
    const w = picked.map(i => WORDS[i]);
    setWords(w);
    const r = generateRounds(w, rng);
    setRounds(r);
    return { picked, w, r };
  }, []);

  const triggerParticles = (type) => {
    setParticles({ active: false, type });
    requestAnimationFrame(() => setParticles({ active: true, type }));
    setTimeout(() => setParticles({ active: false, type }), 1200);
  };

  const triggerShake = () => { setShake(true); setTimeout(() => setShake(false), 400); };

  const showComboPopup = (c) => { setComboPopup(c); setTimeout(() => setComboPopup(null), 1000); };
  const showXpPopup = (xp) => { setXpPopup(xp); setTimeout(() => setXpPopup(null), 1000); };

  const handleStart = () => {
    const today = getDayKey();
    setupWords(st, today);
    setLearnIdx(0); setRIdx(0); setScore(0); setXpGained(0); setCombo(0); setMaxCombo(0);
    setSpeedMode(false); setSpeedPhase("off"); setSpeedScore(0); setSpeedTotal(0);
    setQuizScore(0); setQuizTotal(0);
    setIsBonusRound(false);
    playFx("learn_start");
    setPhase("learn");
  };

  const handlePlayMore = () => {
    const newRoundNum = bonusRoundNum + 1;
    setBonusRoundNum(newRoundNum);
    const seed = getDayKey() + "-bonus-" + newRoundNum;
    const rng = seededRng(seed);
    // Pick words not yet seen in this session if possible
    const seenSet = new Set(st.seenIdx || []);
    let avail = WORDS.map((_,i) => i).filter(i => !seenSet.has(i));
    if (avail.length < 5) avail = WORDS.map((_,i) => i); // cycle through all
    const picked = shuffle(avail, rng).slice(0, 5);
    const w = picked.map(i => WORDS[i]);
    setWords(w);
    const r = generateRounds(w, rng);
    setRounds(r);
    setLearnIdx(0); setRIdx(0); setScore(0); setXpGained(0); setCombo(0); setMaxCombo(0);
    setSpeedMode(false); setSpeedPhase("off"); setSpeedScore(0); setSpeedTotal(0);
    setQuizScore(0); setQuizTotal(0);
    setIsBonusRound(true);
    playFx("learn_start");
    setPhase("learn");
  };

  const handleLearnNext = () => {
    if (learnIdx < words.length - 1) { playFx("learn_card"); setLearnIdx(learnIdx + 1); }
    else { playFx("quiz_start"); setPhase("quiz"); }
  };

  const handleAnswer = (choice) => {
    if (selected !== null) return;
    setSelected(choice);
    const correct = choice === rounds[rIdx].answer;
    let earnedXP = 0;

    if (correct) {
      const newCombo = combo + 1;
      setCombo(newCombo);
      setMaxCombo(m => Math.max(m, newCombo));
      setScore(s => s + 1);
      earnedXP = XP_PER_CORRECT + Math.min(newCombo - 1, 10) * XP_COMBO_BONUS;
      if (speedPhase === "active") { earnedXP += XP_SPEED_BONUS; setSpeedScore(s => s + 1); }
      setXpGained(x => x + earnedXP);
      playFx(newCombo >= 3 ? "combo" : "correct");
      triggerParticles(newCombo >= 5 ? "combo" : "correct");
      if (newCombo >= 3) showComboPopup(newCombo);
      showXpPopup(earnedXP);
    } else {
      setCombo(0);
      playFx("wrong");
      triggerShake();
    }
    if (speedPhase === "active") setSpeedTotal(t => t + 1);
    setShowExplain(true);
  };

  const handleNext = async () => {
    setSelected(null); setShowExplain(false);
    if (rIdx < rounds.length - 1) {
      setRIdx(rIdx + 1);
    } else if (speedPhase !== "done" && speedPhase !== "active") {
      // â† Save regular quiz stats NOW before startSpeedRound replaces rounds[]
      setQuizScore(score);
      setQuizTotal(rounds.length);
      setSpeedPhase("pre");
    } else {
      await finishGame();
    }
  };

  const startSpeedRound = () => {
    // Generate quick-fire rounds from today's words
    const rng = seededRng(getDayKey() + "-speed");
    const speedRounds = [];
    words.forEach(w => {
      if (w.roots.length > 0) {
        const r = w.roots[0];
        const wrongs = ROOT_MEANINGS_POOL.filter(m => m !== r.meaning);
        speedRounds.push({ type:"speed_root", wordObj:w, q:`"${r.part}" = ?`, sub:w.word,
          choices: shuffle([r.meaning, ...shuffle(wrongs, rng).slice(0,3)], rng), answer: r.meaning,
          explain:`${r.part} = "${r.meaning}"` });
      }
      const origins = [...new Set(WORDS.map(x=>x.origin))];
      speedRounds.push({ type:"speed_origin", wordObj:w, q:`${w.word}`, sub:"Which language?",
        choices: shuffle([w.origin, ...shuffle(origins.filter(o=>o!==w.origin), rng).slice(0,3)], rng), answer: w.origin,
        explain: w.etymology });
    });
    const sr = shuffle(speedRounds, rng).slice(0, 10);
    setRounds(sr); setRIdx(0); setSpeedPhase("active"); setSpeedTimer(30); setSpeedScore(0); setSpeedTotal(0);
    playFx("speed_go");

    // Timer â€” ticks only, timeup handled in effect
    if (timerRef.current) clearInterval(timerRef.current);
    timerRef.current = setInterval(() => {
      setSpeedTimer(t => {
        if (t <= 1) { clearInterval(timerRef.current); timerRef.current = null; return 0; }
        if (t <= 6) playFx("tick");
        return t - 1;
      });
    }, 1000);
  };

  // Handle speed timer hitting 0 â€” play timeup here so it's guaranteed clear of interval
  useEffect(() => {
    if (speedPhase === "active" && speedTimer === 0) {
      if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; }
      playFx("timeup");
      setSpeedPhase("done");
    }
  }, [speedTimer, speedPhase]);

  useEffect(() => { return () => { if (timerRef.current) clearInterval(timerRef.current); }; }, []);

  // Keyboard shortcuts: 1-4 select quiz answers; Space/Enter confirm
  useEffect(() => {
    const onKey = (e) => {
      if (phase !== "quiz" || speedPhase === "pre" || speedPhase === "done") return;
      if (!rounds[rIdx]) return;
      if (selected !== null && (e.key === " " || e.key === "Enter")) {
        e.preventDefault(); handleNext(); return;
      }
      const idx = parseInt(e.key) - 1;
      if (idx >= 0 && idx < rounds[rIdx].choices.length && selected === null) {
        handleAnswer(rounds[rIdx].choices[idx]);
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [phase, speedPhase, rounds, rIdx, selected, handleNext]);

  const finishGame = async () => {
    // Always kill timer first â€” prevents ticks/timeup bleeding into results screen
    if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; }
    // quizScore/quizTotal saved in handleNext before speed round replaced rounds[]
    // Fall back to live score/rounds if speed round never ran
    const qScore = quizTotal > 0 ? quizScore : score;
    const qTotal = quizTotal > 0 ? quizTotal : rounds.length;
    const pct = qScore / (qTotal || 1);
    let bonusXP = 0;
    if (pct === 1) bonusXP = XP_PERFECT_BONUS;
    const totalXP = xpGained + bonusXP;

    let newXP = (st.xp || 0) + totalXP;
    let newLevel = st.level || 1;
    let leveledUp = false;
    while (newXP >= xpForLevel(newLevel)) { newXP -= xpForLevel(newLevel); newLevel++; leveledUp = true; }
    if (leveledUp) { playFx("levelup"); triggerParticles("levelup"); }
    else { setTimeout(() => playFx("results"), 350); }

    const pickedIdx = words.map(w => WORDS.indexOf(w)).filter(i => i >= 0);
    const newSeen = [...new Set([...(st.seenIdx || []), ...pickedIdx])];

    if (isBonusRound) {
      setBonusScore(s => s + qScore);
      setBonusTotal(t => t + qTotal);
      const ns = { ...st, xp:newXP, level:newLevel, totalWords:(st.totalWords||0)+words.length,
        seenIdx:newSeen, soundOn,
        todayQuizScore:qScore, todayQuizTotal:qTotal,
        todaySpeedScore:speedScore, todaySpeedTotal:speedTotal, todayXP:totalXP };
      setSt(ns); await save(ns); setXpGained(totalXP); setPhase("results");
    } else {
      const newStreak = (st.streak || 0) + 1;
      const ns = { ...st, completedToday:true,
        todayQuizScore:qScore, todayQuizTotal:qTotal,
        todaySpeedScore:speedScore, todaySpeedTotal:speedTotal, todayXP:totalXP,
        streak:newStreak, bestStreak:Math.max(newStreak, st.bestStreak||0),
        totalWords:(st.totalWords||0)+words.length,
        xp:newXP, level:newLevel, lastDay:getDayKey(), seenIdx:newSeen, soundOn };
      setSt(ns); await save(ns); setXpGained(totalXP); setPhase("results");
    }
  };

  const toggleSound = async () => {
    const ns = !soundOn;
    setSoundOn(ns);
    // Resume suspended AudioContext on user gesture
    if (ns && audioCtx && audioCtx.state === "suspended") audioCtx.resume();
    if (st) { const updated = { ...st, soundOn: ns }; setSt(updated); await save(updated); }
  };

  // Round type labels
  const roundLabel = (type) => {
    const map = { root_meaning:"ðŸŒ± Root Meaning", origin:"ðŸ—ºï¸ Language Origin", relatives:"ðŸŒ³ Word Family",
      etymology_match:"ðŸ“œ True Etymology", reverse:"ðŸ”„ Reverse Match", speed_root:"âš¡ Speed Root", speed_origin:"âš¡ Speed Origin",
      funfact_match:"ðŸ’¡ Fun Fact Detective" };
    return map[type] || "ðŸ“– Etymology";
  };

  const getMsg = () => {
    const pct = (st?.todayQuizScore || 0) / (st?.todayQuizTotal || 1);
    if (pct >= 0.9) return "Etymologist extraordinaire!";
    if (pct >= 0.7) return "A fine philological mind.";
    if (pct >= 0.5) return "Solid roots taking hold.";
    return "Every master was once a beginner.";
  };

  if (phase === "loading") return (
    <div className="ey-app"><div style={{display:"flex",alignItems:"center",justifyContent:"center",minHeight:"60vh",flexDirection:"column"}}>
      <div className="ey-logo">WordSpark</div><div className="ey-logo-sub">Etymology</div>
      <div style={{color:"var(--tx3)",marginTop:16,fontSize:".85rem",animation:"eyPulse 1.5s infinite"}}>Loading...</div>
    </div></div>
  );

  const level = st?.level || 1;
  const xp = st?.xp || 0;
  const xpNeeded = xpForLevel(level);
  const xpPct = Math.min(xp / xpNeeded * 100, 100);

  return (
    <div className={`ey-app ${shake ? "ey-shake" : ""}`} ref={appRef}>
      <Particles active={particles.active} type={particles.type} />

      {/* Floating popups */}
      {comboPopup && <div className="ey-combo-popup" key={comboPopup}>ðŸ”¥ {comboPopup}x COMBO!</div>}
      {xpPopup && <div className="ey-xp-popup" key={`xp-${Date.now()}`}>+{xpPopup} XP</div>}

      {/* HEADER */}
      <div className="ey-header">
        <div className="ey-header-top">
          <div>
            <div className="ey-logo">WordSpark</div>
            <div className="ey-logo-sub">Etymology</div>
          </div>
          <div style={{display:"flex",gap:8,alignItems:"center"}}>
            <button className="ey-sound-btn" title="Your Profile"
              onClick={() => { if (phase !== "profile") { setPrevPhase(phase); setPhase("profile"); } else setPhase(prevPhase); }}>
              {phase === "profile" ? "âœ•" : "â—ˆ"}
            </button>
            <button className="ey-sound-btn" onClick={toggleSound}>{soundOn ? "ðŸ”Š" : "ðŸ”‡"}</button>
          </div>
        </div>
        <div className="ey-xp-bar-wrap">
          <div className="ey-xp-bar-bg">
            <div className="ey-xp-bar-fill" style={{ width: `${xpPct}%` }} />
          </div>
          <div className="ey-xp-info">
            <span className="ey-level-badge">Lv.{level}</span>
            <span className="ey-xp-text">{xp}/{xpNeeded} XP</span>
            <span className="ey-title">{getTitle(level)}</span>
          </div>
        </div>
        <div className="ey-stats-row">
          <div className="ey-stat"><div className="ey-stat-val">{st?.streak||0}</div><div className="ey-stat-lbl">Streak</div></div>
          <div className="ey-stat"><div className="ey-stat-val">{st?.totalWords||0}</div><div className="ey-stat-lbl">Words</div></div>
          <div className="ey-stat"><div className="ey-stat-val">{st?.bestStreak||0}</div><div className="ey-stat-lbl">Best</div></div>
        </div>
      </div>

      {/* WELCOME */}
      {phase === "welcome" && (
        <div className="ey-welcome">
          <div className="ey-hero">Uncover the <em>hidden stories</em> buried inside everyday words</div>
          <div className="ey-feat-grid">
            <div className="ey-feat-card"><div className="ey-feat-icon">ðŸ›ï¸</div><div className="ey-feat-title">5 Words Daily</div><div className="ey-feat-desc">Deep etymological breakdowns with roots, timelines, and family trees</div></div>
            <div className="ey-feat-card"><div className="ey-feat-icon">ðŸ§ </div><div className="ey-feat-title">6 Quiz Types</div><div className="ey-feat-desc">Root meanings, origins, word families, etymologies, reverse matching, and Fun Fact Detective</div></div>
            <div className="ey-feat-card"><div className="ey-feat-icon">âš¡</div><div className="ey-feat-title">Speed Round</div><div className="ey-feat-desc">30-second lightning round for bonus XP after the main quiz</div></div>
            <div className="ey-feat-card"><div className="ey-feat-icon">â™¾ï¸</div><div className="ey-feat-title">Play More</div><div className="ey-feat-desc">Finished today's set? Keep going with fresh words â€” no daily cap</div></div>
          </div>
          <button className="ey-start-btn" onClick={handleStart}>
            <span className="ey-start-icon">ðŸ“œ</span> Begin Today's Etymology
          </button>
        </div>
      )}

      {/* LEARN PHASE */}
      {phase === "learn" && words[learnIdx] && (() => {
        const w = words[learnIdx];
        return (
          <div className="ey-learn" key={`learn-${learnIdx}`}>
            <div className="ey-prog-bar">{words.map((_,i) => <div key={i} className={`ey-prog-dot ${i===learnIdx?"active":i<learnIdx?"done":""}`} />)}</div>
            <div className="ey-phase-label"><span>Learn</span> Word {learnIdx+1} of {words.length}{isBonusRound ? <span style={{marginLeft:8,color:"var(--amber)"}}>â™¾ï¸ Bonus</span> : null}</div>

            <div className="ey-word-card">
              <div className="ey-word-top">
                <div className="ey-word-main">{w.word}</div>
                <button className="ey-speak-btn" onClick={()=>speak(w.word)}>ðŸ”Š</button>
              </div>
              <div className="ey-word-meta">{w.pos} Â· {w.ipa} Â· {langIcon(w.origin)} {w.origin} Â· {w.year}</div>
              <div className="ey-word-def">{w.def}</div>

              <div className="ey-ety-section">
                <div className="ey-ety-label">Etymology</div>
                <div className="ey-ety-story">{w.etymology}</div>
              </div>

              <div className="ey-ety-section">
                <div className="ey-ety-label">Root Breakdown</div>
                <div className="ey-roots-grid">
                  {w.roots.map((r,i) => (
                    <div key={i} className="ey-root-chip">
                      <div className="ey-root-part">{r.part}</div>
                      <div className="ey-root-meaning">"{r.meaning}"</div>
                      <div className="ey-root-lang">{langIcon(r.lang)} {r.lang}</div>
                    </div>
                  ))}
                </div>
              </div>

              <div className="ey-ety-section">
                <div className="ey-ety-label">Word Evolution</div>
                <div className="ey-evo">{w.evolution.map((s,i) => <div key={i} className={`ey-evo-step ${i===w.evolution.length-1?"final":""}`}>{s}</div>)}</div>
              </div>

              <div className="ey-ety-section">
                <div className="ey-ety-label">Word Relatives</div>
                <div className="ey-rel-list">{w.relatives.map((r,i) => <span key={i} className="ey-rel-tag">{r}</span>)}</div>
              </div>

              <div className="ey-funfact">
                <div className="ey-ff-title">ðŸ’¡ Did You Know?</div>
                <div className="ey-ff-text">{w.funFact}</div>
              </div>
            </div>

            <button className="ey-continue-btn" onClick={handleLearnNext}>
              {learnIdx < words.length - 1 ? "Next Word â†’" : "Start the Quiz â†’"}
            </button>
          </div>
        );
      })()}

      {/* QUIZ PHASE */}
      {phase === "quiz" && speedPhase === "pre" && (
        <div className="ey-speed-intro" key="speed-intro">
          <div className="ey-speed-icon">âš¡</div>
          <div className="ey-speed-title">SPEED ROUND</div>
          <div className="ey-speed-desc">30 seconds. 10 rapid-fire questions. Bonus XP for every correct answer.</div>
          <div className="ey-speed-stakes">
            <div className="ey-speed-stake">+{XP_SPEED_BONUS} XP per correct</div>
            <div className="ey-speed-stake">Combos still active ðŸ”¥</div>
          </div>
          <button className="ey-start-btn" onClick={startSpeedRound}>
            <span className="ey-start-icon">âš¡</span> GO!
          </button>
        </div>
      )}

      {phase === "quiz" && speedPhase === "done" && (
        <div className="ey-speed-done" key="speed-done">
          <div className="ey-speed-icon">âš¡</div>
          <div className="ey-speed-title">TIME'S UP!</div>
          <div className="ey-speed-result">{speedScore} / {speedTotal} in speed round</div>
          <button className="ey-start-btn" onClick={finishGame}>
            <span className="ey-start-icon">ðŸ“Š</span> See Final Results
          </button>
        </div>
      )}

      {phase === "quiz" && (speedPhase === "off" || speedPhase === "active") && rounds[rIdx] && (() => {
        const round = rounds[rIdx];
        const isSpeed = speedPhase === "active";
        return (
          <div className="ey-quiz" key={`quiz-${rIdx}-${speedPhase}`}>
            {/* Timer bar for speed round */}
            {isSpeed && (
              <div className="ey-timer-wrap">
                <div className="ey-timer-bar" style={{ width: `${(speedTimer/30)*100}%`, background: speedTimer <= 5 ? "var(--err)" : "var(--gold)" }} />
                <div className={`ey-timer-text ${speedTimer <= 5 ? "ey-timer-danger" : ""}`}>{speedTimer}s</div>
              </div>
            )}

            {!isSpeed && <div className="ey-prog-bar">{rounds.map((_,i) => <div key={i} className={`ey-prog-dot ${i===rIdx?"active":i<rIdx?"done":""}`} />)}</div>}

            <div className="ey-quiz-header">
              <div className="ey-quiz-counter">{isSpeed ? "âš¡ Speed" : "Quiz"} <span>{rIdx+1}</span> / <span>{rounds.length}</span></div>
              {combo >= 2 && <div className="ey-combo-badge">ðŸ”¥ {combo}x</div>}
            </div>

            <div className="ey-quiz-type">{roundLabel(round.type)}</div>
            <div className={`ey-quiz-q${round.type==="funfact_match"?" funfact":""}`}>{round.q}</div>
            <div className="ey-quiz-sub">{round.sub}</div>

            <div className="ey-choices">
              {round.choices.map((c, i) => {
                let cls = "ey-choice";
                if (selected !== null) {
                  if (c === round.answer) cls += " correct";
                  else if (c === selected) cls += " wrong";
                }
                return (
                  <button key={i} className={cls} onClick={() => handleAnswer(c)} disabled={selected !== null}>
                    {!isSpeed && selected === null && <span className="ey-choice-key">{i+1}</span>}
                    {c}
                  </button>
                );
              })}
            </div>

            {showExplain && !isSpeed && (
              <div className="ey-explanation">
                <div className="ey-explain-text">{round.explain}</div>
              </div>
            )}

            {showExplain && (
              <button className="ey-next-btn" onClick={handleNext}>
                {isSpeed ? "Next â†’" : rIdx < rounds.length - 1 ? "Next Question â†’" : "Speed Round âš¡"}
              </button>
            )}
          </div>
        );
      })()}

      {/* RESULTS */}
      {phase === "results" && (() => {
        // Pull from saved state (accurate) or live state for freshly-finished game
        const dQScore  = st?.todayQuizScore  ?? (quizTotal > 0 ? quizScore : score);
        const dQTotal  = st?.todayQuizTotal  ?? (quizTotal > 0 ? quizTotal : rounds.length);
        const dSScore  = st?.todaySpeedScore ?? speedScore;
        const dSTotal  = st?.todaySpeedTotal ?? speedTotal;
        const dXP      = st?.todayXP ?? xpGained;
        const quizPct  = dQTotal > 0 ? Math.round(dQScore / dQTotal * 100) : 0;
        const speedPct = dSTotal > 0 ? Math.round(dSScore / dSTotal * 100) : null;
        return (
          <div className="ey-results">
            {/* Hero accuracy */}
            <div className="ey-res-score">{quizPct}%</div>
            <div className="ey-res-label">quiz accuracy Â· {dQScore} of {dQTotal} correct</div>
            <div className="ey-res-msg">{getMsg()}</div>

            {/* Stat row */}
            <div className="ey-res-stat-grid">
              <div className="ey-res-stat-card">
                <div className="ey-res-stat-val">+{dXP}</div>
                <div className="ey-res-stat-lbl">XP earned</div>
              </div>
              {speedPct !== null && (
                <div className="ey-res-stat-card">
                  <div className="ey-res-stat-val">{speedPct}%</div>
                  <div className="ey-res-stat-lbl">speed round Â· {dSScore}/{dSTotal}</div>
                </div>
              )}
              {maxCombo >= 3 && (
                <div className="ey-res-stat-card">
                  <div className="ey-res-stat-val">Ã—{maxCombo}</div>
                  <div className="ey-res-stat-lbl">best combo</div>
                </div>
              )}
              <div className="ey-res-stat-card">
                <div className="ey-res-stat-val">{st?.totalWords || 0}</div>
                <div className="ey-res-stat-lbl">total words</div>
              </div>
            </div>

            {/* Perfect score badge */}
            {dQTotal > 0 && dQScore === dQTotal && (
              <div className="ey-perfect-badge">â­ Perfect Round â€” +{XP_PERFECT_BONUS} bonus XP</div>
            )}

            {/* Streak badge */}
            {(st?.streak || 0) > 0 && (
              <div className="ey-res-streak">ðŸ”¥ {st.streak}-day streak{st.streak >= 3 ? " â€” on fire!" : ""}</div>
            )}

            {/* XP / Level card */}
            <div className="ey-xp-level-card">
              <div className="ey-xlc-top">
                <span className="ey-xlc-level">Level {level}</span>
                <span className="ey-xlc-title">{getTitle(level)}</span>
              </div>
              <div className="ey-xp-bar-bg large">
                <div className="ey-xp-bar-fill" style={{ width: `${xpPct}%` }} />
              </div>
              <div className="ey-xlc-xp">{xp} / {xpNeeded} XP Â· {xpNeeded - xp} to level {level + 1}</div>
            </div>

            <div className="ey-review-section">
              <div className="ey-review-title">Today's Etymologies</div>
              {words.map((w, i) => (
                <div key={i} className="ey-review-card">
                  <div className="ey-review-top">
                    <div className="ey-review-word">
                      <span>{w.word}</span>
                      <button className="ey-speak-btn sm" onClick={()=>speak(w.word)}>ðŸ”Š</button>
                    </div>
                    <div className="ey-review-origin">{langIcon(w.origin)} {w.origin} Â· {w.year}</div>
                  </div>
                  <div className="ey-review-ety">{w.etymology}</div>
                  <div className="ey-review-roots">{w.roots.map((r,j) => <span key={j} className="ey-review-root"><b>{r.part}</b> = "{r.meaning}"</span>)}</div>
                </div>
              ))}
            </div>

            <div className="ey-done-card">
              <div className="ey-done-text">{isBonusRound ? "Keep the streak going â€” more words await!" : "Come back tomorrow for 5 new etymologies"}</div>
              <div className="ey-done-sub" style={{marginBottom:16}}>{isBonusRound ? `Bonus round complete Â· ${bonusRoundNum} extra set${bonusRoundNum>1?"s":""} played` : "New words unlock at midnight Â· Or play more right now!"}</div>
              <div style={{display:"flex",gap:10,marginBottom:12}}>
                <button className="ey-start-btn" style={{flex:1}} onClick={handlePlayMore}>
                  <span className="ey-start-icon">â™¾ï¸</span> Play More
                </button>
                <button className="ey-share-btn"
                  onClick={() => {
                    const dQScore = st?.todayQuizScore ?? score;
                    const dQTotal = st?.todayQuizTotal ?? rounds.length;
                    const pct = Math.round(dQScore/dQTotal*100);
                    const txt = `WordSpark Etymology â€” ${pct}% quiz accuracy Â· Level ${level} ${getTitle(level)} Â· ${st?.streak||0}-day streak ðŸ”¥`;
                    navigator.clipboard?.writeText(txt).then(() => setScoreShared(true));
                    setTimeout(() => setScoreShared(false), 2500);
                  }}>
                  {scoreShared ? "âœ“ Copied!" : "Share"}
                </button>
              </div>
            </div>
          </div>
        );
      })()}
      {/* PROFILE SCREEN */}
      {phase === "profile" && (() => {
        const learnedWords = (st?.seenIdx || []).map(i => WORDS[i]).filter(Boolean);
        const sortedWords = [...learnedWords].sort((a,b) => {
          if (profileSortBy === "alpha") return a.word.localeCompare(b.word);
          if (profileSortBy === "origin") return a.origin.localeCompare(b.origin) || a.word.localeCompare(b.word);
          return 0;
        });
        const filtered = profileWordFilter
          ? sortedWords.filter(w =>
              w.word.toLowerCase().includes(profileWordFilter.toLowerCase()) ||
              w.def.toLowerCase().includes(profileWordFilter.toLowerCase()) ||
              w.origin.toLowerCase().includes(profileWordFilter.toLowerCase()) ||
              w.etymology.toLowerCase().includes(profileWordFilter.toLowerCase()))
          : sortedWords;

        // Derive meaningful stats
        const lastAccuracy = st?.todayQuizScore != null && st?.todayQuizTotal
          ? Math.round(st.todayQuizScore / st.todayQuizTotal * 100)
          : null;
        const totalXPEarned = (st?.level > 1)
          ? Array.from({length:(st?.level||1)-1},(_,i)=>xpForLevel(i+1)).reduce((a,b)=>a+b,0) + (st?.xp||0)
          : (st?.xp||0);

        return (
          <div className="ey-profile" key="profile">
            {/* Level Glyph */}
            <div className="ey-profile-glyph-wrap">
              <LevelGlyph level={level} xpPct={xpPct} size={200} />
            </div>

            <div className="ey-profile-title-row">
              <div className="ey-profile-name">{getTitle(level)}</div>
              <div className="ey-profile-level-badge">Level {level}</div>
            </div>

            {/* XP progress */}
            <div className="ey-profile-xp-section">
              <div className="ey-xp-bar-bg" style={{height:8,borderRadius:4,overflow:"hidden",marginBottom:6}}>
                <div className="ey-xp-bar-fill" style={{width:`${xpPct}%`}} />
              </div>
              <div style={{display:"flex",justifyContent:"space-between",fontSize:".7rem",color:"var(--tx3)"}}>
                <span>{xp} / {xpNeeded} XP</span>
                <span>{xpNeeded - xp} to Level {level+1}</span>
              </div>
            </div>

            {/* Stats grid â€” 6 stats that are all genuinely meaningful */}
            <div className="ey-profile-stat-grid">
              <div className="ey-profile-stat">
                <div className="ey-profile-stat-val">{st?.streak || 0}</div>
                <div className="ey-profile-stat-lbl">Day Streak</div>
              </div>
              <div className="ey-profile-stat">
                <div className="ey-profile-stat-val">{st?.bestStreak || 0}</div>
                <div className="ey-profile-stat-lbl">Best Streak</div>
              </div>
              <div className="ey-profile-stat">
                <div className="ey-profile-stat-val">{learnedWords.length}</div>
                <div className="ey-profile-stat-lbl">Words Studied</div>
              </div>
              <div className="ey-profile-stat">
                <div className="ey-profile-stat-val">{Math.floor((st?.totalWords||0)/5)}</div>
                <div className="ey-profile-stat-lbl">Sessions</div>
              </div>
              <div className="ey-profile-stat">
                <div className="ey-profile-stat-val">{learnedWords.length > 0 ? [...new Set(learnedWords.map(w=>w.origin))].length : 0}</div>
                <div className="ey-profile-stat-lbl">Origins Found</div>
              </div>
              <div className="ey-profile-stat">
                <div className="ey-profile-stat-val">{totalXPEarned.toLocaleString()}</div>
                <div className="ey-profile-stat-lbl">Total XP</div>
              </div>
            </div>

            {/* Origin breakdown */}
            {learnedWords.length > 0 && (() => {
              const originCounts = {};
              learnedWords.forEach(w => { originCounts[w.origin] = (originCounts[w.origin]||0) + 1; });
              const topOrigins = Object.entries(originCounts).sort((a,b)=>b[1]-a[1]).slice(0,5);
              return (
                <div className="ey-profile-origins">
                  {topOrigins.map(([orig, count]) => (
                    <div key={orig} className="ey-profile-origin-row">
                      <span className="ey-profile-origin-lang">{langIcon(orig)} {orig.split(" ")[0]}</span>
                      <div className="ey-profile-origin-bar-wrap">
                        <div className="ey-profile-origin-bar" style={{width:`${Math.round(count/learnedWords.length*100)}%`}} />
                      </div>
                      <span className="ey-profile-origin-count">{count}</span>
                    </div>
                  ))}
                </div>
              );
            })()}

            {/* Lexicon */}
            <div className="ey-profile-lexicon">
              <div className="ey-profile-lex-header">
                <span className="ey-review-title" style={{display:"block",marginBottom:0}}>
                  Lexicon Â· {learnedWords.length} word{learnedWords.length!==1?"s":""}
                </span>
                {learnedWords.length > 0 && (
                  <span style={{fontSize:".65rem",color:"var(--tx3)"}}>tap to expand</span>
                )}
              </div>
              {learnedWords.length > 1 && (
                <div className="ey-profile-sort-row">
                  {[["recent","Recent"],["alpha","Aâ€“Z"],["origin","Origin"]].map(([key,label]) => (
                    <button key={key} className={`ey-profile-sort-btn${profileSortBy===key?" active":""}`}
                      onClick={() => setProfileSortBy(key)}>{label}</button>
                  ))}
                </div>
              )}
              {learnedWords.length === 0 ? (
                <div className="ey-profile-empty">Complete your first session to build your lexicon.</div>
              ) : (
                <>
                  <input className="ey-profile-search"
                    placeholder="Search words, origins, definitionsâ€¦"
                    value={profileWordFilter}
                    onChange={e => setProfileWordFilter(e.target.value)} />
                  <div className="ey-profile-lex-list">
                    {filtered.length === 0 && (
                      <div className="ey-profile-empty">No matches found.</div>
                    )}
                    {filtered.map((w, i) => {
                      const isOpen = expandedLexWord === w.word;
                      return (
                        <div key={i}
                          className={`ey-profile-lex-card ${isOpen ? "open" : ""}`}
                          onClick={() => setExpandedLexWord(isOpen ? null : w.word)}>
                          {/* Collapsed header â€” always visible */}
                          <div className="ey-profile-lex-top">
                            <div className="ey-profile-lex-word">
                              <span>{w.word}</span>
                              <button className="ey-speak-btn sm"
                                onClick={e=>{e.stopPropagation();speak(w.word);}}>ðŸ”Š</button>
                            </div>
                            <div style={{display:"flex",alignItems:"center",gap:8}}>
                              <div className="ey-review-origin">{langIcon(w.origin)} {w.origin}</div>
                              <span className="ey-lex-chevron">{isOpen ? "â–²" : "â–¼"}</span>
                            </div>
                          </div>
                          <div style={{fontSize:".78rem",color:"var(--tx2)",fontStyle:"italic",lineHeight:1.4,marginTop:2}}>
                            {w.def}
                          </div>

                          {/* Expanded full detail */}
                          {isOpen && (
                            <div className="ey-lex-expanded" onClick={e=>e.stopPropagation()}>
                              {/* Meta row */}
                              <div className="ey-lex-meta-row">
                                <span className="ey-lex-meta-chip">{w.pos}</span>
                                <span className="ey-lex-meta-chip">{w.ipa}</span>
                                <span className="ey-lex-meta-chip">{w.year}</span>
                              </div>

                              {/* Etymology */}
                              <div className="ey-lex-section-label">Etymology</div>
                              <div className="ey-ety-story" style={{fontSize:".9rem",marginBottom:12}}>{w.etymology}</div>

                              {/* Root breakdown */}
                              <div className="ey-lex-section-label">Root Breakdown</div>
                              <div className="ey-roots-grid" style={{marginBottom:12}}>
                                {w.roots.map((r,j) => (
                                  <div key={j} className="ey-root-chip">
                                    <div className="ey-root-part">{r.part}</div>
                                    <div className="ey-root-meaning">"{r.meaning}"</div>
                                    <div className="ey-root-lang">{langIcon(r.lang)} {r.lang}</div>
                                  </div>
                                ))}
                              </div>

                              {/* Evolution */}
                              <div className="ey-lex-section-label">Word Evolution</div>
                              <div className="ey-evo" style={{marginBottom:12}}>
                                {w.evolution.map((s,j) => (
                                  <div key={j} className={`ey-evo-step ${j===w.evolution.length-1?"final":""}`}>{s}</div>
                                ))}
                              </div>

                              {/* Relatives */}
                              {w.relatives.length > 0 && (
                                <>
                                  <div className="ey-lex-section-label">Word Relatives</div>
                                  <div className="ey-rel-list" style={{marginBottom:12}}>
                                    {w.relatives.map((r,j) => <span key={j} className="ey-rel-tag">{r}</span>)}
                                  </div>
                                </>
                              )}

                              {/* Fun Fact */}
                              <div className="ey-funfact">
                                <div className="ey-ff-title">ðŸ’¡ Did You Know?</div>
                                <div className="ey-ff-text">{w.funFact}</div>
                              </div>
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                </>
              )}
            </div>
          </div>
        );
      })()}
    </div>
  );
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STYLES
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const CSS = `
@import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500&family=Outfit:wght@300;400;500;600;700;800&display=swap');

:root {
  --bg:#0f0e0c;--bg2:#1a1814;--sf:#1e1b17;--sf2:#2a2520;--sf3:#332d27;
  --bd:rgba(196,164,106,.12);--bd2:rgba(196,164,106,.22);
  --gold:#c4a46a;--gold2:#d4b87a;--goldDim:rgba(196,164,106,.6);--amber:#e8a849;
  --warmWhite:#f0e6d3;--cream:#d4c5a9;
  --tx:#e8dcc8;--tx2:#9a8e7a;--tx3:#6b6052;
  --ok:#7eb87e;--err:#c75d5d;--errBg:rgba(199,93,93,.1);--okBg:rgba(126,184,126,.1);
}
*{margin:0;padding:0;box-sizing:border-box}
body,#root{background:var(--bg);min-height:100vh;font-family:'Outfit',sans-serif;color:var(--tx);-webkit-font-smoothing:antialiased}

.ey-app{max-width:540px;margin:0 auto;padding:16px 16px 40px;min-height:100vh;position:relative;overflow:hidden}
.ey-app::before{content:'';position:fixed;inset:0;background:radial-gradient(ellipse at 20% 0%,rgba(196,164,106,.06) 0%,transparent 60%),radial-gradient(ellipse at 80% 100%,rgba(196,164,106,.04) 0%,transparent 60%);pointer-events:none;z-index:0;animation:eyBreath 18s ease-in-out infinite}
@keyframes eyBreath{0%,100%{opacity:.7}50%{opacity:1}}

.ey-shake{animation:eyShake .4s ease}
@keyframes eyShake{0%,100%{transform:translateX(0)}20%{transform:translateX(-6px)}40%{transform:translateX(6px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}}

/* â”€â”€â”€ HEADER â”€â”€â”€ */
.ey-header{position:relative;z-index:1;margin-bottom:20px}
.ey-header-top{display:flex;justify-content:space-between;align-items:flex-start}
.ey-logo{font-family:'Cormorant Garamond',serif;font-size:2rem;font-weight:700;color:var(--gold);line-height:1}
.ey-logo-sub{font-family:'Cormorant Garamond',serif;font-size:.75rem;font-style:italic;color:var(--tx2);letter-spacing:3px;text-transform:uppercase}
.ey-sound-btn{background:var(--sf);border:1px solid var(--bd);border-radius:8px;padding:6px 10px;cursor:pointer;font-size:1rem;color:var(--tx2)}

.ey-xp-bar-wrap{margin-top:12px}
.ey-xp-bar-bg{height:6px;background:var(--sf2);border-radius:3px;overflow:hidden;position:relative}
.ey-xp-bar-bg.large{height:10px;border-radius:5px}
.ey-xp-bar-fill{height:100%;background:linear-gradient(90deg,var(--gold),var(--amber));border-radius:3px;transition:width .6s ease}
.ey-xp-info{display:flex;align-items:center;gap:8px;margin-top:4px;font-size:.7rem}
.ey-level-badge{background:linear-gradient(135deg,var(--gold),var(--amber));color:var(--bg);padding:2px 8px;border-radius:4px;font-weight:700;font-size:.65rem}
.ey-xp-text{color:var(--tx2)}
.ey-title{color:var(--goldDim);font-style:italic;margin-left:auto}

.ey-stats-row{display:flex;justify-content:center;gap:28px;margin-top:10px}
.ey-stat{text-align:center}
.ey-stat-val{font-family:'Cormorant Garamond',serif;font-size:1.4rem;font-weight:700;color:var(--gold)}
.ey-stat-lbl{font-size:.6rem;text-transform:uppercase;letter-spacing:1.5px;color:var(--tx3)}

/* â”€â”€â”€ WELCOME â”€â”€â”€ */
.ey-welcome{position:relative;z-index:1;animation:eyIn .6s ease}
.ey-hero{font-family:'Cormorant Garamond',serif;font-size:1.4rem;font-weight:400;line-height:1.6;color:var(--cream);margin-bottom:24px;font-style:italic;text-align:center}
.ey-hero em{color:var(--gold);font-style:normal;font-weight:600}

.ey-feat-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:24px}
.ey-feat-card{background:var(--sf);border:1px solid var(--bd);border-radius:12px;padding:16px 14px;text-align:center}
.ey-feat-icon{font-size:1.6rem;margin-bottom:6px}
.ey-feat-title{font-size:.8rem;font-weight:700;color:var(--tx);margin-bottom:4px}
.ey-feat-desc{font-size:.7rem;color:var(--tx2);line-height:1.4}

.ey-start-btn{width:100%;padding:16px;background:linear-gradient(135deg,var(--gold),var(--amber));border:none;border-radius:14px;color:var(--bg);font-family:'Outfit',sans-serif;font-size:1rem;font-weight:700;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center;gap:8px}
.ey-start-btn:hover{transform:translateY(-2px);box-shadow:0 8px 24px rgba(196,164,106,.3)}
.ey-start-icon{font-size:1.2rem}

/* â”€â”€â”€ LEARN â”€â”€â”€ */
.ey-learn{position:relative;z-index:1;animation:eyIn .5s ease}
.ey-prog-bar{display:flex;gap:3px;margin-bottom:16px}
.ey-prog-dot{flex:1;height:3px;border-radius:2px;background:var(--sf2);transition:background .3s}
.ey-prog-dot.active{background:var(--gold)}
.ey-prog-dot.done{background:var(--ok)}

.ey-phase-label{font-size:.68rem;text-transform:uppercase;letter-spacing:2px;color:var(--tx3);margin-bottom:12px}
.ey-phase-label span{color:var(--gold);font-weight:700}

.ey-word-card{background:var(--sf);border:1px solid var(--bd);border-radius:16px;padding:24px 20px;margin-bottom:12px}
.ey-word-top{display:flex;align-items:baseline;justify-content:space-between;margin-bottom:4px}
.ey-word-main{font-family:'Cormorant Garamond',serif;font-size:2.1rem;font-weight:700;color:var(--gold);line-height:1.1}
.ey-speak-btn{background:rgba(196,164,106,.1);border:1px solid rgba(196,164,106,.2);border-radius:8px;padding:6px 10px;cursor:pointer;font-size:.95rem;transition:all .2s;color:var(--gold);flex-shrink:0}
.ey-speak-btn.sm{padding:3px 7px;font-size:.8rem}
.ey-speak-btn:hover{background:rgba(196,164,106,.2)}
.ey-word-meta{font-size:.78rem;color:var(--tx2);font-style:italic;margin-bottom:12px}
.ey-word-def{font-size:.95rem;color:var(--tx);line-height:1.5;margin-bottom:14px;padding-bottom:14px;border-bottom:1px solid var(--bd)}

.ey-ety-section{margin-bottom:14px}
.ey-ety-label{font-size:.62rem;text-transform:uppercase;letter-spacing:2px;color:var(--tx3);margin-bottom:6px}
.ey-ety-story{font-family:'Cormorant Garamond',serif;font-size:1rem;font-style:italic;color:var(--cream);line-height:1.6}

.ey-roots-grid{display:flex;flex-wrap:wrap;gap:8px}
.ey-root-chip{background:rgba(196,164,106,.07);border:1px solid rgba(196,164,106,.14);border-radius:10px;padding:10px 14px;flex:1;min-width:110px}
.ey-root-part{font-family:'Cormorant Garamond',serif;font-size:1.1rem;font-weight:700;color:var(--gold2)}
.ey-root-meaning{font-size:.75rem;color:var(--tx2)}
.ey-root-lang{font-size:.62rem;color:var(--tx3);margin-top:2px}

.ey-evo{display:flex;flex-direction:column;position:relative;padding-left:20px}
.ey-evo::before{content:'';position:absolute;left:6px;top:8px;bottom:8px;width:1px;background:linear-gradient(to bottom,var(--gold),rgba(196,164,106,.2))}
.ey-evo-step{position:relative;padding:5px 0 5px 16px;font-size:.82rem;color:var(--tx2)}
.ey-evo-step::before{content:'';position:absolute;left:-17px;top:50%;transform:translateY(-50%);width:7px;height:7px;border-radius:50%;background:var(--bg);border:1.5px solid var(--gold)}
.ey-evo-step.final{color:var(--gold);font-weight:600}
.ey-evo-step.final::before{background:var(--gold)}

.ey-rel-list{display:flex;flex-wrap:wrap;gap:6px}
.ey-rel-tag{background:rgba(196,164,106,.06);border:1px solid rgba(196,164,106,.12);border-radius:20px;padding:4px 12px;font-size:.75rem;color:var(--cream)}

.ey-funfact{background:rgba(232,168,73,.06);border:1px solid rgba(232,168,73,.12);border-radius:12px;padding:14px 16px;margin-top:12px}
.ey-ff-title{font-size:.62rem;text-transform:uppercase;letter-spacing:2px;color:var(--amber);margin-bottom:4px;font-weight:700}
.ey-ff-text{font-size:.82rem;color:var(--cream);line-height:1.6}

.ey-continue-btn{width:100%;padding:14px;background:rgba(196,164,106,.1);border:1.5px solid rgba(196,164,106,.25);border-radius:12px;color:var(--gold);font-family:'Outfit',sans-serif;font-size:.9rem;font-weight:600;cursor:pointer;transition:all .2s}
.ey-continue-btn:hover{background:rgba(196,164,106,.18);transform:translateY(-2px)}

/* â”€â”€â”€ QUIZ â”€â”€â”€ */
.ey-quiz{position:relative;z-index:1;animation:eyIn .4s ease}
.ey-quiz-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.ey-quiz-counter{font-size:.7rem;text-transform:uppercase;letter-spacing:2px;color:var(--tx3)}
.ey-quiz-counter span{color:var(--gold)}
.ey-combo-badge{background:linear-gradient(135deg,#ff6b6b,#ffd93d);color:#000;padding:4px 12px;border-radius:20px;font-size:.72rem;font-weight:800;animation:eyPulse .6s infinite}
.ey-quiz-type{display:inline-flex;align-items:center;gap:6px;background:rgba(196,164,106,.08);border:1px solid rgba(196,164,106,.15);border-radius:20px;padding:4px 12px;font-size:.68rem;text-transform:uppercase;letter-spacing:1.5px;color:var(--goldDim);margin-bottom:14px}
.ey-quiz-q{font-family:'Cormorant Garamond',serif;font-size:1.4rem;font-weight:600;color:var(--warmWhite);line-height:1.4;margin-bottom:4px}
.ey-quiz-q.funfact{font-size:1.05rem;font-style:italic;color:var(--cream);background:rgba(232,168,73,.06);border:1px solid rgba(232,168,73,.12);border-radius:12px;padding:14px 16px;margin-bottom:4px}
.ey-quiz-sub{font-size:.8rem;color:var(--tx2);font-style:italic;margin-bottom:18px}

.ey-choices{display:flex;flex-direction:column;gap:8px;margin-bottom:14px}
.ey-choice{width:100%;text-align:left;padding:13px 16px;background:var(--sf);border:1.5px solid var(--bd);border-radius:12px;color:var(--tx);font-family:'Outfit',sans-serif;font-size:.85rem;line-height:1.4;cursor:pointer;transition:all .15s}
.ey-choice:hover:not(:disabled){border-color:var(--bd2);background:var(--sf2)}
.ey-choice.correct{border-color:var(--ok);background:var(--okBg);color:var(--ok);transform:scale(1.02)}
.ey-choice.wrong{border-color:var(--err);background:var(--errBg);color:var(--err);opacity:.7}
.ey-choice:disabled{cursor:default}

.ey-explanation{background:rgba(196,164,106,.06);border:1px solid rgba(196,164,106,.12);border-radius:12px;padding:12px 16px;margin-bottom:12px;animation:eyIn .3s ease}
.ey-explain-text{font-size:.82rem;color:var(--cream);line-height:1.5}

.ey-next-btn{width:100%;padding:14px;background:linear-gradient(135deg,var(--gold),var(--amber));border:none;border-radius:12px;color:var(--bg);font-family:'Outfit',sans-serif;font-size:.9rem;font-weight:700;cursor:pointer;transition:all .2s}
.ey-next-btn:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(196,164,106,.2)}

/* â”€â”€â”€ SPEED ROUND â”€â”€â”€ */
.ey-timer-wrap{position:relative;margin-bottom:16px}
.ey-timer-bar{height:6px;border-radius:3px;transition:width 1s linear}
.ey-timer-text{position:absolute;right:0;top:-18px;font-size:.8rem;font-weight:700;color:var(--gold)}
.ey-timer-danger{color:var(--err) !important;animation:eyPulse .5s infinite}

.ey-speed-intro,.ey-speed-done{text-align:center;position:relative;z-index:1;animation:eyIn .5s ease;padding-top:30px}
.ey-speed-icon{font-size:3.5rem;margin-bottom:8px;animation:eyBounce 1s infinite}
.ey-speed-title{font-family:'Outfit',sans-serif;font-size:2rem;font-weight:800;letter-spacing:3px;background:linear-gradient(135deg,#ffd93d,#ff6b6b,#ffd93d);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;margin-bottom:12px}
.ey-speed-desc{color:var(--tx2);font-size:.9rem;margin-bottom:20px;line-height:1.5}
.ey-speed-stakes{display:flex;justify-content:center;gap:16px;margin-bottom:28px}
.ey-speed-stake{background:var(--sf);border:1px solid var(--bd);border-radius:10px;padding:10px 16px;font-size:.8rem;color:var(--cream)}
.ey-speed-result{font-family:'Cormorant Garamond',serif;font-size:2rem;color:var(--gold);margin-bottom:24px}

@keyframes eyBounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}

/* â”€â”€â”€ RESULTS â”€â”€â”€ */
.ey-results{position:relative;z-index:1;animation:eyIn .6s ease;text-align:center}
.ey-res-score{font-family:'Cormorant Garamond',serif;font-size:4rem;font-weight:700;color:var(--gold);line-height:1}
.ey-res-label{font-size:.82rem;color:var(--tx2);margin-bottom:8px}
.ey-res-msg{font-family:'Cormorant Garamond',serif;font-size:1.2rem;font-weight:500;font-style:italic;color:var(--cream);margin-bottom:20px}

.ey-res-stat-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:8px;margin-bottom:14px}
.ey-res-stat-card{background:var(--sf);border:1px solid var(--bd);border-radius:12px;padding:12px 10px;text-align:center}
.ey-res-stat-val{font-family:'Cormorant Garamond',serif;font-size:1.6rem;font-weight:700;color:var(--gold);line-height:1.1}
.ey-res-stat-lbl{font-size:.62rem;text-transform:uppercase;letter-spacing:1.5px;color:var(--tx3);margin-top:3px;line-height:1.3}

.ey-res-streak{background:rgba(232,168,73,.08);border:1px solid rgba(232,168,73,.16);border-radius:100px;display:inline-block;padding:6px 18px;font-size:.78rem;font-weight:600;color:var(--amber);margin-bottom:14px}

.ey-res-badges{display:flex;flex-wrap:wrap;justify-content:center;gap:8px;margin-bottom:20px}
.ey-badge{background:var(--sf);border:1px solid var(--bd);border-radius:100px;padding:6px 16px;font-size:.78rem;font-weight:600;color:var(--cream)}
.ey-badge.gold{background:rgba(196,164,106,.12);border-color:rgba(196,164,106,.25);color:var(--gold)}

.ey-xp-level-card{background:var(--sf);border:1px solid var(--bd);border-radius:14px;padding:18px;margin-bottom:24px;text-align:left}
.ey-xlc-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.ey-xlc-level{font-family:'Cormorant Garamond',serif;font-size:1.2rem;font-weight:700;color:var(--gold)}
.ey-xlc-title{font-size:.78rem;color:var(--goldDim);font-style:italic}
.ey-xlc-xp{font-size:.72rem;color:var(--tx3);margin-top:6px;text-align:center}

.ey-review-section{text-align:left;margin-bottom:20px}
.ey-review-title{font-size:.62rem;text-transform:uppercase;letter-spacing:2px;color:var(--tx3);margin-bottom:10px;text-align:left}
.ey-review-card{background:var(--sf);border:1px solid var(--bd);border-radius:12px;padding:14px;margin-bottom:8px}
.ey-review-top{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;flex-wrap:wrap;gap:6px}
.ey-review-word{display:flex;align-items:center;gap:8px;font-family:'Cormorant Garamond',serif;font-size:1.2rem;font-weight:700;color:var(--gold)}
.ey-review-origin{font-size:.68rem;color:var(--tx3);background:rgba(196,164,106,.06);padding:3px 10px;border-radius:20px;border:1px solid var(--bd);white-space:nowrap}
.ey-review-ety{font-size:.78rem;color:var(--tx2);font-style:italic;line-height:1.5;margin-bottom:6px}
.ey-review-roots{display:flex;flex-wrap:wrap;gap:5px}
.ey-review-root{font-size:.68rem;background:rgba(196,164,106,.06);border:1px solid rgba(196,164,106,.1);border-radius:6px;padding:3px 8px;color:var(--cream)}

.ey-done-card{background:var(--sf);border:1px solid var(--bd);border-radius:12px;padding:18px;text-align:center}
.ey-done-text{font-family:'Cormorant Garamond',serif;font-size:1rem;color:var(--cream);font-style:italic;margin-bottom:4px}
.ey-done-sub{font-size:.72rem;color:var(--tx3)}

/* â”€â”€â”€ FLOATING POPUPS â”€â”€â”€ */
.ey-combo-popup{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-family:'Outfit',sans-serif;font-size:1.8rem;font-weight:800;background:linear-gradient(135deg,#ff6b6b,#ffd93d);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;z-index:100;pointer-events:none;animation:eyPopup .8s ease forwards}
.ey-xp-popup{position:fixed;top:45%;left:50%;transform:translate(-50%,-50%);font-family:'Outfit',sans-serif;font-size:1.2rem;font-weight:700;color:var(--gold);z-index:100;pointer-events:none;animation:eyXpFloat 1s ease forwards;text-shadow:0 0 20px rgba(196,164,106,.5)}

@keyframes eyPopup{0%{opacity:0;transform:translate(-50%,-50%) scale(.5)}30%{opacity:1;transform:translate(-50%,-50%) scale(1.3)}100%{opacity:0;transform:translate(-50%,-80%) scale(1)}}
@keyframes eyXpFloat{0%{opacity:0;transform:translate(-50%,-50%)}20%{opacity:1}100%{opacity:0;transform:translate(-50%,-120%)}}
@keyframes eyIn{from{opacity:0;transform:translateY(16px)}to{opacity:1;transform:translateY(0)}}
@keyframes eyPulse{0%,100%{opacity:1}50%{opacity:.5}}

/* â”€â”€â”€ KEYBOARD HINTS â”€â”€â”€ */
.ey-choice-key{display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;border-radius:4px;background:rgba(196,164,106,.12);border:1px solid rgba(196,164,106,.18);font-size:.62rem;font-weight:700;color:var(--tx3);margin-right:8px;flex-shrink:0;font-family:'Outfit',sans-serif;letter-spacing:0}

/* â”€â”€â”€ PERFECT BADGE â”€â”€â”€ */
.ey-perfect-badge{background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(255,165,0,.1));border:1px solid rgba(255,215,0,.3);border-radius:100px;display:inline-block;padding:8px 20px;font-size:.82rem;font-weight:700;color:#ffd700;margin-bottom:12px;text-align:center;width:100%;animation:eyIn .5s ease;text-shadow:0 0 12px rgba(255,215,0,.3)}

/* â”€â”€â”€ EXPANDED LEX CARD â”€â”€â”€ */
.ey-profile-lex-card{cursor:pointer;transition:border-color .2s,background .2s}
.ey-profile-lex-card.open{border-color:var(--bd2);background:var(--sf2)}
.ey-lex-chevron{font-size:.6rem;color:var(--tx3);flex-shrink:0}
.ey-lex-expanded{margin-top:14px;padding-top:14px;border-top:1px solid var(--bd);animation:eyIn .3s ease}
.ey-lex-meta-row{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px}
.ey-lex-meta-chip{font-size:.68rem;background:rgba(196,164,106,.08);border:1px solid var(--bd);border-radius:6px;padding:3px 10px;color:var(--tx2)}
.ey-lex-section-label{font-size:.58rem;text-transform:uppercase;letter-spacing:2px;color:var(--tx3);margin-bottom:6px}

::-webkit-scrollbar{width:4px}::-webkit-scrollbar-track{background:var(--bg)}::-webkit-scrollbar-thumb{background:var(--bd);border-radius:4px}

/* â”€â”€â”€ PROFILE â”€â”€â”€ */
.ey-profile{position:relative;z-index:1;animation:eyIn .5s ease;padding-bottom:40px}
.ey-profile-glyph-wrap{display:flex;justify-content:center;margin:4px 0 18px}
.ey-profile-title-row{display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:16px}
.ey-profile-name{font-family:'Cormorant Garamond',serif;font-size:1.3rem;font-weight:600;color:var(--gold);font-style:italic}
.ey-profile-level-badge{background:linear-gradient(135deg,var(--gold),var(--amber));color:var(--bg);padding:3px 10px;border-radius:6px;font-size:.7rem;font-weight:800;letter-spacing:1px}
.ey-profile-xp-section{margin-bottom:20px;padding:0 2px}
.ey-profile-stat-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:18px}
.ey-profile-stat{background:var(--sf);border:1px solid var(--bd);border-radius:12px;padding:14px 10px;text-align:center}
.ey-profile-stat-val{font-family:'Cormorant Garamond',serif;font-size:1.8rem;font-weight:700;color:var(--gold);line-height:1.1}
.ey-profile-stat-lbl{font-size:.58rem;text-transform:uppercase;letter-spacing:1.5px;color:var(--tx3);margin-top:4px;line-height:1.3}

.ey-profile-origins{background:var(--sf);border:1px solid var(--bd);border-radius:12px;padding:14px 16px;margin-bottom:20px}
.ey-profile-origin-row{display:flex;align-items:center;gap:10px;margin-bottom:7px}
.ey-profile-origin-row:last-child{margin-bottom:0}
.ey-profile-origin-lang{font-size:.7rem;color:var(--tx2);min-width:70px;white-space:nowrap}
.ey-profile-origin-bar-wrap{flex:1;height:4px;background:var(--sf2);border-radius:2px;overflow:hidden}
.ey-profile-origin-bar{height:100%;background:linear-gradient(90deg,var(--gold),var(--amber));border-radius:2px;transition:width .8s ease}
.ey-profile-origin-count{font-size:.7rem;color:var(--tx3);min-width:16px;text-align:right;font-weight:600}

.ey-profile-lexicon{text-align:left}
.ey-profile-lex-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
.ey-profile-sort-row{display:flex;gap:6px;margin-bottom:10px}
.ey-profile-sort-btn{background:var(--sf);border:1px solid var(--bd);border-radius:8px;padding:5px 12px;font-size:.7rem;color:var(--tx2);cursor:pointer;transition:all .15s;font-family:'Outfit',sans-serif}
.ey-profile-sort-btn.active{background:rgba(196,164,106,.12);border-color:rgba(196,164,106,.3);color:var(--gold);font-weight:600}
.ey-profile-search{width:100%;background:var(--sf);border:1px solid var(--bd);border-radius:10px;padding:10px 14px;color:var(--tx);font-family:'Outfit',sans-serif;font-size:.82rem;outline:none;margin-bottom:10px;transition:border-color .2s}
.ey-profile-search:focus{border-color:var(--bd2)}
.ey-profile-search::placeholder{color:var(--tx3)}
.ey-profile-lex-list{display:flex;flex-direction:column;gap:8px}
.ey-profile-lex-card{background:var(--sf);border:1px solid var(--bd);border-radius:12px;padding:14px;cursor:pointer;transition:border-color .15s,background .15s}
.ey-profile-lex-card:hover{border-color:var(--bd2)}
.ey-profile-lex-card.open{border-color:rgba(196,164,106,.32);background:rgba(196,164,106,.04)}
.ey-profile-lex-top{display:flex;align-items:center;justify-content:space-between;margin-bottom:5px;flex-wrap:wrap;gap:6px}
.ey-profile-lex-word{display:flex;align-items:center;gap:8px;font-family:'Cormorant Garamond',serif;font-size:1.2rem;font-weight:700;color:var(--gold)}
.ey-lex-chevron{font-size:.6rem;color:var(--tx3);transition:transform .2s}
.ey-profile-lex-card.open .ey-lex-chevron{color:var(--gold)}
.ey-profile-empty{font-size:.82rem;color:var(--tx3);text-align:center;padding:24px 0;font-style:italic}

.ey-lex-expanded{border-top:1px solid var(--bd);margin-top:12px;padding-top:14px;animation:eyIn .25s ease}
.ey-lex-meta-row{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px}
.ey-lex-meta-chip{background:rgba(196,164,106,.07);border:1px solid rgba(196,164,106,.12);border-radius:6px;padding:2px 8px;font-size:.68rem;color:var(--tx3)}
.ey-lex-section-label{font-size:.6rem;text-transform:uppercase;letter-spacing:2px;color:var(--tx3);margin-bottom:6px;font-weight:600}

.ey-share-btn{background:var(--sf);border:1.5px solid var(--bd);border-radius:14px;color:var(--tx2);font-family:'Outfit',sans-serif;font-size:.82rem;font-weight:600;padding:0 18px;cursor:pointer;transition:all .2s;white-space:nowrap;min-width:82px}
.ey-share-btn:hover{border-color:rgba(196,164,106,.35);color:var(--gold)}
`;


